#!/usr/bin/env python3
# qual-challs.rtfm.re:9001
import sys
from gmpy2 import invert


def solve_crypto(n, phi, r):
    assert n % r == 0
    pq = n // r
    if r % 4 == 1:
        raise RuntimeError("(r-1)/2 is even")
    inv_r1mid = invert((r - 1) // 2, 2**2050)

    # ((p-1)*(q-1)*2) mod 2**2050
    phi_pq_mul2 = (phi * inv_r1mid) % 2**2050
    assert phi_pq_mul2 % 2 == 0
    sum_p_q = ((-(phi_pq_mul2 // 2 - pq - 1)) % (2**2049))

    delta = (sum_p_q ** 2) - 4 * pq

    # Compute the precise root by dichotomy, because math.sqrt operates on floats
    sqrt_min = 0
    sqrt_max = delta
    while sqrt_min < sqrt_max - 1:
        testing = (sqrt_min + sqrt_max) // 2
        if testing * testing > delta:
            sqrt_max = testing
        elif testing * testing < delta:
            sqrt_min = testing
        else:
            sqrt_min = sqrt_max = testing
    while sqrt_min < sqrt_max and sqrt_min * sqrt_min < delta:
        sqrt_min += 1
    if sqrt_min * sqrt_min != delta:
        raise ValueError("* ... Unable to find a square root for the discriminant of the polynom")

    p = (sum_p_q - sqrt_min) // 2
    q = (sum_p_q + sqrt_min) // 2
    assert n == p * q * r
    real_phi = (p - 1) * (q - 1) * (r - 1)
    d = invert(0x10001, real_phi)
    return d


def test():
    in_N = 46685356825053513175963532344241150615944887667515896950457640281528752799861859591797015222959752074181005335861759675443489749729837786639223039920941036431792082958510197948509953942091987220930670927509491750246622825763288729941298218628284851423072702041452257410071612040166841624641341686681600480878382261479702317399557889001524243344701038764187316984629223494814491792433532000428930402437958401062444646183915354662568099918859254935450326737230636271276091630679748039815144938626086034172210619666624995904830779539825182266644469274279237736415855845085558287180203555923805513729448259235948708256243747040066224396748146417782195514882768918036733924389320499841644024349009562786631658451806206344482934378607305149789180649182571302064916030372564043472846515737542814440008079649038373727674153997610927581895345814293067972687221383894212509839036437791610759830813361907334615706850449882162606818339437
    in_phi = 109378501112817523795816444866258172106699983514367920067730915319699114946609341402638989264863360967583468921304383456668772845988681677742806578464263144649864104530911986271550840008935425234479724674505958589573598810481177228050894289432706339063002125556436354787304888166253188847002297825796568117381300018215492469979694393663932070735748081466602659604072945386064726963737320245135889344803123372163785220276913140899766764760496894096870065612304170058716586202345118473241616169092446778531341131676045855094694876789380265302672801979761815846123505700846805807278882744810558154778302274898822309367376
    in_r = 1536203247998318099920587575436567586172540835685749662430696525591059348516216432581435585432498546442484779682037976457527827597468095364192883256476329405927573282219623976139912669641822476630158560157669646872621641023180950068522776280520637869788089707511875111171514131274567632078453311648509521089423

    d = solve_crypto(in_N, in_phi, in_r)
    print(d)

test()

import socket
s = socket.create_connection(('qual-challs.rtfm.re', 9001))

def recv():
    data = s.recv(1024)
    print("[<] %r" % data)
    if not data:
        sys.exit(0)
    return data

def send(data):
    print('[>] %r' % data)
    s.send(data)

lines = b''
while len(lines.splitlines()) < 4:
    lines += recv()

lines = lines.decode().splitlines()
print(repr(lines))
n = int(lines[0].split(' ', 1)[1].strip())
phi = int(lines[1].split(' ', 1)[1].strip())
r = int(lines[2].split(' ', 1)[1].strip())
d = solve_crypto(n, phi, r)
send((str(d) + "\n").encode())

recv()
