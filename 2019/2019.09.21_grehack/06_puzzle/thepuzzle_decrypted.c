/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_1140();
// char *getenv(const char *name);
// void free(void *ptr);
// int putchar(int c);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// char *strncpy(char *dest, const char *src, size_t n);
// int strncmp(const char *s1, const char *s2, size_t n);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// __pid_t getpid(void);
// clock_t clock(void);
// int fclose(FILE *stream);
// size_t strlen(const char *s);
// char *strchr(const char *s, int c);
// int printf(const char *format, ...);
// char *strrchr(const char *s, int c);
// void *memset(void *s, int c, size_t n);
// double pow(double x, double y);
// int close(int fd);
// ssize_t read(int fd, void *buf, size_t nbytes);
// unsigned __int64 strtoull(const char *nptr, char **endptr, int base);
// void *calloc(size_t nmemb, size_t size);
// int strcmp(const char *s1, const char *s2);
// Display *XOpenDisplay(const char *);
// int fprintf(FILE *stream, const char *format, ...);
// __int64 ftell(FILE *stream);
// void *memcpy(void *dest, const void *src, size_t n);
// int kill(__pid_t pid, int sig);
// void *malloc(size_t size);
// int mkstemp(char *template);
// int fseek(FILE *stream, __int64 off, int whence);
// __int64 ptrace(enum __ptrace_request request, ...);
// FILE *fdopen(int fd, const char *modes);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int open(const char *file, int oflag, ...);
// FILE *fopen(const char *filename, const char *modes);
// __ssize_t getline(char **lineptr, size_t *n, FILE *stream);
// void __noreturn exit(int status);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strdup(const char *s);
// int XCloseDisplay(Display *);
// XImage *XGetImage(Display *, Drawable, int, int, unsigned int, unsigned int, unsigned __int64, int);
// unsigned int sleep(unsigned int seconds);
// __pid_t fork(void);
// int rand(void);
// int usleep(__useconds_t useconds);
// __int64 __fastcall _cxa_finalize(_QWORD); weak
__int64 (**_internal_ITM_deregisterTMCloneTable_ptr())(void);
__int64 (**_internal_fini())(void);
__int64 _internal__init();
_BOOL8 __fastcall compare_with_root(const char *a1);
__int64 is_USER_root();
void __fastcall child_main(__int64 a1);
char __fastcall parent_process(unsigned int a1, const char *a2, char *a3);
__int64 __fastcall main(signed int a1, char **a2, char **a3);
unsigned __int64 get_mapped_start_addr_from_proc_self_maps();
unsigned __int64 __fastcall ptrace_child(unsigned int a1);
__int64 __fastcall BREAKPOINT_add_new(__int64 a1);
__int64 __fastcall BREAKPOINT_add_new_with_cb(__int64 a1, __int64 a2, char *a3, __int64 a4);
void __fastcall BREAKPOINT_reset_entry(__int64 a1, char a2);
void __fastcall BREAKPOINT_reset_entry_with_offset(__int64 a1, char a2);
__int64 __fastcall BREAKPONT_remove_bp_in_child_zone(__int64 a1, __int64 a2);
__int64 __fastcall BREAKPONT_restore_bp_in_child_zone(__int64 a1, __int64 a2, char a3);
__int64 __fastcall BREAKPOINT_set_orginal_byte_with_child_offset(__int64 a1, char a2);
__int64 __fastcall BREAKPOINT_handle_SIGTRAP_breakpoint(__int64 a1);
__int64 __fastcall BREAKPOINT_run_as_if_triggered_with_CHILD_rip(char a1);
_BYTE *__fastcall read_child_mem_by_offset(__int64 a1, int a2);
_BYTE *__fastcall read_child_mem(__int64 a1, int a2);
__int64 __fastcall CHILD__xor_addr_with_value(__int64 a1, __int64 a2);
__int64 __fastcall write_child_mem_by_offset(__int64 a1, int a2, __int64 a3);
__int64 __fastcall write_child_mem(__int64 a1, int a2, __int64 a3);
void __fastcall CHILD__memcpy(__int64 a1, int a2, __int64 a3);
void __fastcall CHILD__hexdump_mem(int a1, int a2);
void *CHILD__get_user_regs_struct();
__int64 __fastcall CHILD__set_user_regs_struct(__int64 a1);
void __fastcall CHILD__flip_ZF_if_0x7A(char a1);
__int64 __fastcall CHILD__get_reg_value(const char *a1);
void __fastcall CHILD__set_reg_value(const char *a1, __int64 a2);
__int64 __fastcall file_process_begin__load_function(const char *a1, FILE *a2);
__int64 __fastcall RUN_block_by_name(const char *a1);
void __fastcall CHILD__emulate_call_with_child_offset(__int64 a1);
void CHILD__emulate_ret();
__int64 __fastcall get_child_offset_from_addr(__int64 a1);
char *__fastcall transform_4bytes_into_3bytes_key_using_CRYPTO(__int64 a1);
__int64 __fastcall decrypt_a_function(__int64 a1);
_DWORD *__fastcall BITMAP_get_next_transparent_pixel_PTR_y_x(BITMAP *bmp, unsigned int *py, _DWORD *px); // idb
char __fastcall ENC_PART_maybe_match_bitmap__internal(ENC_PART *part, BITMAP *bmp);
__int64 __fastcall ENC_PART_maybe_match_bitmap(ENC_PART *a1, BITMAP *a2); // idb
__int64 __fastcall BITMAP_is_croppedsquare_seems_good(BITMAP *a1, unsigned int a2, int a3, unsigned int a4, int a5, unsigned int a6); // idb
__int64 __fastcall sub_3EA2(__int64 a1);
BITMAP *__fastcall BITMAP_crop_0x38square_and_extract_filled_pt_with_dezoom2(BITMAP *bmp, unsigned int ypos, unsigned int xpos, _DWORD *pNumberFullPixels, __int64 pYmax, __int64 pYmin, __int64 pXmax, __int64 pXmin); // idb
char *__fastcall ENC_PART_do_OCR_text_on_screenshot(ENC_PART *parts, BITMAP *screenshot);
ENC_TYPE_I_SUB *__fastcall ENCDATA_load_part_I_subpart_rectangle_bytes_with_attr(FILE *file);
void __fastcall sub_42A4(BITMAP **a1);
_BOOL8 __fastcall is_space(char a1);
void *parse_u64_from_linebuffer_with_static_var();
void *parse_reg_name_and_get_value();
signed __int64 parse_token_and_return_kind();
unsigned int *__fastcall parse_next_token_given_current_kind(int a1);
unsigned int *__fastcall parse_recurr__left_of_minus_star(unsigned int *a1);
__int64 __fastcall parse_recurr__multiplication(__int64 a1, _QWORD *a2);
__int64 __fastcall parse_recurr__right_of_plusminus(_QWORD *a1);
__int64 __fastcall parse_recurr__plus(__int64 a1, _QWORD *a2);
__int64 __fastcall parse_expr__in_parenthesis(_QWORD *a1);
void __fastcall RUN_line(char *a1);
int __fastcall load_debug_script_file(const char *a1, __int64 a2, int a3);
BITMAP *__fastcall BITMAP_from_screenshot(_BYTE *img_data, signed int width, unsigned int height);
BITMAP *open_display_and_get_image();
signed __int64 __fastcall sub_536A(__int64 a1, _QWORD ***a2, _DWORD *a3);
void __fastcall sub_543A(void *a1, unsigned __int8 a2);
ENC_PART *__fastcall ENCDATA_load_part_I(FILE *file);
ENC_TYPE_L *__fastcall ENCDATA_load_part_L(FILE *a1);
ENC_PART *__fastcall ENCDATA_load_recursive_parts(FILE *file);
__int64 __fastcall ENC_PART_recursive_compure_score(ENC_PART *enc_part, BITMAP *bmp, ENC_TYPE_I_SUB **pResult, float *pMinNorm2, __m128i a5); // idb
FILE *__fastcall ENC_fopen_with_read_4_bytes(const char *a1);
_BYTE __fastcall BITMAP_set_pixelcol_from_RGB(unsigned __int8 *a1, unsigned __int8 red, int gr, unsigned __int8 blue);
BITMAP *__fastcall BITMAP_insert_transparent_point(BITMAP *bmp, int y, int x);
void __fastcall BITMAP_set_pixel_value(BITMAP *bmp, unsigned int y, unsigned int x, u8 val);
void __fastcall BITMAP_set_pixel_from_RGB_maybe_transparent(BITMAP *bmp, unsigned int y, unsigned int x, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6);
BITMAP *__fastcall BITMAP_free_one_transparent_pt(BITMAP *a1);
void __fastcall BITMAP_free(BITMAP *a1);
void **__fastcall alloc_array_of_memblocks(unsigned int count, unsigned int size);
BITMAP *__fastcall BITMAP_new_with_h_w(unsigned int height, unsigned int width);
BITMAP *__fastcall BITMAP_crop_yxhw(BITMAP *a1, unsigned int ypos, unsigned int xpos, unsigned int new_h, unsigned int new_w, _DWORD *pNumberFullPixels); // idb
BITMAP *__fastcall BITMAP_shrink_with_scale(BITMAP *a1, unsigned int scale); // idb
BITMAP *__fastcall BITMAP_crop_around_filled_pixels_and_give_YX_maxmin(BITMAP *a1, unsigned int *pYmax, unsigned int *pYmin, unsigned int *pXmax, unsigned int *pXmin); // idb
float __fastcall BITMAP_get_norm2_delta(BITMAP *bmp1, BITMAP *bmp2); // idb
BITMAP *__fastcall ENCDATA_load_rectangle_bytes(FILE *a1);
_BOOL8 __fastcall compute_SHA256_and_compare_with_flag(const char *pszInput); // idb
void __noreturn sub_69B5();
void __fastcall __noreturn start_routine(void *a1);
_BOOL8 __fastcall sub_6A5D(void *a1);
SHA256_CTX *__fastcall SHA256_update_block_512bits(SHA256_CTX *a1, _BYTE *block64); // idb
SHA256_CTX *__fastcall SHA256_init(SHA256_CTX *ctx); // idb
__int64 __fastcall SHA256_update(SHA256_CTX *ctx, _BYTE *data, unsigned __int64 size);
SHA256_CTX *__fastcall SHA256_final(SHA256_CTX *a1, _BYTE *pDigest); // idb
void __fastcall crypto_free_state(void **a1);
_DWORD *__fastcall crypto_keySchedule(__int64 a1, int a2);
__int64 __fastcall crypto_getByteStream(__int64 a1);
_BYTE *__fastcall crypto_encrypt_xorStreamCipher(__int64 a1, int a2, __int64 a3, int a4);
_BYTE *__fastcall base64_decode(__int64 a1, unsigned int a2);
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3);
void term_proc();
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 _gmon_start__(void); weak
// __int64 Jv_RegisterClasses(void); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
_UNKNOWN unk_8612; // weak
_UNKNOWN unk_8680; // weak
char asc_8C5C[1] = "H"; // idb
__m128i a5 = { { 255, 255, 127, 127, 128, 150, 24, 74, 73, 78, 84, 0, 80, 76, 85, 83 } }; // idb
void *__ptr32 off_8C90[46] =
{
  (void *__ptr32 )0xFFFFB8F6LL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB80CLL,
  (void *__ptr32 )0xFFFFB80CLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB80CLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB80CLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8CDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB88FLL,
  (void *__ptr32 )0xFFFFB8AELL,
  (void *__ptr32 )0xFFFFB86DLL,
  (void *__ptr32 )0xFFFFB829LL,
  (void *__ptr32 )0xFFFFB8FDLL,
  (void *__ptr32 )0xFFFFB84BLL
}; // weak
void *__ptr32 off_8D48[8] =
{
  (void *__ptr32 )0xFFFFB8F9LL,
  (void *__ptr32 )0xFFFFB98ELL,
  (void *__ptr32 )0xFFFFB936LL,
  (void *__ptr32 )0xFFFFB98ELL,
  (void *__ptr32 )0xFFFFB95FLL,
  (void *__ptr32 )0xFFFFB98ELL,
  (void *__ptr32 )0xFFFFB919LL,
  (void *__ptr32 )0xFFFFB981LL
}; // weak
char off_8D81[] = { 'r', '+', '\0', '\0' }; // idb
char off_8D88[] = { 'r', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
_DWORD dword_8DE0[64] =
{
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
}; // idb
__int64 (__fastcall *off_20AD98[2])() = { &_internal__init, &_internal_fini }; // weak
__int64 (__fastcall *off_20ADA0)() = &_internal_fini; // weak
_UNKNOWN unk_20ADA8; // weak
void *off_20B188 = &off_20B188; // weak
__pid_t pid = 4294935959; // idb
_BYTE g_final_flag_encrypted[32] =
{
  62,
  32,
  11,
  223,
  168,
  103,
  106,
  95,
  87,
  151,
  120,
  17,
  174,
  156,
  40,
  59,
  91,
  196,
  170,
  157,
  231,
  252,
  221,
  16,
  86,
  193,
  134,
  17,
  163,
  126,
  159,
  58
};
char _bss_start; // weak
_UNKNOWN unk_20B247; // weak
_UNKNOWN g_breakpoint_list; // weak
_UNKNOWN g_pBlocks; // weak
__pid_t g_child_pid; // idb
__int64 g_mapped_start_addr; // weak
_QWORD g_level2_breakpoint_offsets_of_decrypted_fct[56]; // idb
_QWORD g_level2_breakpoint_end_offsets[56]; // idb
_QWORD g_level2_breakpoint_hitCounts_offset[56]; // idb
_DWORD g_level2_breakpoint_hitCounts_max_2[56]; // idb
char g_current_reg_name[8]; // idb
_UNKNOWN g_parser_current_u64_value; // weak
_BYTE *g_pszCurrentlyRunningLine__pChar; // idb
unsigned int g_lastTokenKind[2]; // idb
void **g_p_crypto_state_of_child; // idb
// extern struct _IO_FILE *stdout;
// extern _UNKNOWN __cxa_finalize; weak
// extern struct _IO_FILE *stderr;


//----- (0000000000001128) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    result = (__int64 (**)(void))_gmon_start__();
  return result;
}
// 20BC98: using guessed type __int64 _gmon_start__(void);

//----- (0000000000001140) ----------------------------------------------------
void sub_1140()
{
  JUMPOUT(&dword_0);
}
// 0: using guessed type int dword_0;

//----- (0000000000001420) ----------------------------------------------------
#error "1426: positive sp value has been found (funcsize=3)"

//----- (0000000000001450) ----------------------------------------------------
__int64 (**_internal_ITM_deregisterTMCloneTable_ptr())(void)
{
  __int64 (**result)(void); // rax

  result = (__int64 (**)(void))(&unk_20B247 - (_UNKNOWN *)&_bss_start);
  if ( (unsigned __int64)(&unk_20B247 - (_UNKNOWN *)&_bss_start) > 0xE )
  {
    result = &ITM_deregisterTMCloneTable;
    if ( &ITM_deregisterTMCloneTable )
      result = (__int64 (**)(void))ITM_deregisterTMCloneTable();
  }
  return result;
}
// 20B240: using guessed type char _bss_start;
// 20BC90: using guessed type __int64 ITM_deregisterTMCloneTable(void);

//----- (00000000000014E0) ----------------------------------------------------
__int64 (**_internal_fini())(void)
{
  __int64 (**result)(void); // rax

  if ( !_bss_start )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_20B188);
    result = _internal_ITM_deregisterTMCloneTable_ptr();
    _bss_start = 1;
  }
  return result;
}
// 1410: using guessed type __int64 __fastcall _cxa_finalize(_QWORD);
// 20B188: using guessed type void *off_20B188;
// 20B240: using guessed type char _bss_start;

//----- (0000000000001520) ----------------------------------------------------
__int64 _internal__init()
{
  if ( unk_20ADA8 && &Jv_RegisterClasses )
    Jv_RegisterClasses();
  return 0LL;
}
// 20BCA0: using guessed type __int64 Jv_RegisterClasses(void);

//----- (0000000000001550) ----------------------------------------------------
_BOOL8 __fastcall compare_with_root(const char *a1)
{
  return strcmp(a1, "root") == 0;
}

//----- (0000000000001581) ----------------------------------------------------
__int64 is_USER_root()
{
  char *v0; // ST08_8

  v0 = getenv("USER");
  return (unsigned int)compare_with_root(v0);
}

//----- (00000000000015AD) ----------------------------------------------------
void __fastcall child_main(__int64 a1)
{
  FILE *stream; // ST28_8
  char *v_pszInput; // [rsp+18h] [rbp-28h]
  ENC_PART *v3; // [rsp+20h] [rbp-20h]
  BITMAP *v4_screenshot; // [rsp+30h] [rbp-10h]

  if ( (unsigned int)is_USER_root() )
  {
    fwrite("Something looks wrong with your environment!\n", 1uLL, 0x2DuLL, stderr);
    exit(1);
  }
  v4_screenshot = open_display_and_get_image();
  g_p_crypto_state_of_child = (void **)crypto_keySchedule((__int64)"This program cannot be run in DOS mode", 38);
  stream = ENC_fopen_with_read_4_bytes((const char *)a1);
  v3 = ENCDATA_load_recursive_parts(stream);
  fclose(stream);
  v_pszInput = ENC_PART_do_OCR_text_on_screenshot(v3, v4_screenshot);
  if ( v_pszInput )
  {
    if ( (unsigned __int8)compute_SHA256_and_compare_with_flag(v_pszInput) )
      fwrite("Congrats, you're a hacker!\n", 1uLL, 0x1BuLL, stdout);
    else
      fwrite("Nope. You think you're a hacker but you're not, go back to (Gh)id(r)a!\n", 1uLL, 0x47uLL, stdout);
  }
  else
  {
    fwrite("Come on, give me some input to process, man.\n", 1uLL, 0x2DuLL, stdout);
  }
  free(v_pszInput);
  sub_543A(v3, 1u);
  crypto_free_state(g_p_crypto_state_of_child);
  BITMAP_free(v4_screenshot);
}

//----- (0000000000001755) ----------------------------------------------------
char __fastcall parent_process(unsigned int a1, const char *a2, char *a3)
{
  char result; // al
  char *s; // [rsp+8h] [rbp-48h]
  int stat_loc; // [rsp+2Ch] [rbp-24h]
  int v6; // [rsp+30h] [rbp-20h]
  unsigned int v7; // [rsp+34h] [rbp-1Ch]
  void *ptr; // [rsp+38h] [rbp-18h]
  int v9; // [rsp+44h] [rbp-Ch]
  char *v10; // [rsp+48h] [rbp-8h]

  s = a3;
  stat_loc = 0;
  ptr = 0LL;
  v10 = 0LL;
  v9 = 0;
  ptrace_child(a1);
  waitpid(a1, &stat_loc, 0);
  if ( s )
  {
    v7 = strlen(s);
    v10 = base64_decode((__int64)s, v7);
    v9 = strlen(v10);
  }
  else
  {
    v10 = 0LL;
    v9 = 0;
  }
  load_debug_script_file(a2, (__int64)v10, v9);
  if ( v10 )
  {
    free(v10);
    v10 = 0LL;
  }
  while ( 1 )
  {
    waitpid(a1, &stat_loc, 0);
    ptr = CHILD__get_user_regs_struct();
    result = stat_loc & 0x7F;
    if ( !(stat_loc & 0x7F) )
      break;
    result = (char)((stat_loc & 0x7F) + 1) >> 1;
    if ( result > 0 )
      break;
    if ( (unsigned __int8)stat_loc == 127 )
    {
      v6 = (stat_loc >> 8) & 0xFF;
      if ( v6 != 5 )
      {
        if ( v6 == 11 )
          exit(1);
        exit(1);
      }
      BREAKPOINT_handle_SIGTRAP_breakpoint(*((_QWORD *)ptr + 16));
    }
    free(ptr);
    ptr = 0LL;
  }
  return result;
}

//----- (00000000000018C8) ----------------------------------------------------
__int64 __fastcall main(signed int a1, char **a2, char **a3)
{
  char *v3; // rbx
  size_t v4; // rax
  unsigned int v6; // [rsp+14h] [rbp-1Ch]
  signed int i; // [rsp+1Ch] [rbp-14h]

  if ( a1 <= 1 )
  {
    fprintf(stderr, "Usage: ./%s /path/to/ds/file [key] -- aborting\n", *a2, a2);
    exit(1);
  }
  getpid();
  v3 = a2[1];
  v4 = strlen(a2[1]);
  if ( strncmp(".debugging_script", &v3[v4 - 17], 0x11uLL) )
  {
    fwrite("Unknown extension for first argument -- aborting\n", 1uLL, 0x31uLL, stderr);
    exit(1);
  }
  if ( a1 > 2 && strlen(a2[2]) != 4 )
  {
    fwrite("The key must meet our security requirements -- aborting", 1uLL, 0x37uLL, stderr);
    exit(1);
  }
  v6 = fork();
  if ( v6 )
  {
    if ( a1 > 1 )
      parent_process(v6, a2[1], a2[2]);
    else
      parent_process(v6, a2[1], 0LL);
  }
  else
  {
    for ( i = 0; i <= 4; ++i )
      usleep(0x64u);
    child_main((__int64)*a2);
  }
  return 0LL;
}

//----- (0000000000001A5B) ----------------------------------------------------
unsigned __int64 get_mapped_start_addr_from_proc_self_maps()
{
  unsigned __int64 result; // rax
  char buf; // [rsp+0h] [rbp-30h]
  char v2; // [rsp+10h] [rbp-20h]
  char *v3; // [rsp+20h] [rbp-10h]
  int fd; // [rsp+2Ch] [rbp-4h]

  fd = open("/proc/self/maps", 0);
  if ( fd == -1 )
  {
    kill(g_child_pid, 9);
    exit(-1);
  }
  read(fd, &buf, 0x10uLL);
  v2 = 0;
  close(fd);
  v3 = strchr(&buf, 45);
  if ( v3 )
    *v3 = 0;
  result = strtoull(&buf, 0LL, 16);
  g_mapped_start_addr = result;
  return result;
}
// 20B4B8: using guessed type __int64 g_mapped_start_addr;

//----- (0000000000001B05) ----------------------------------------------------
unsigned __int64 __fastcall ptrace_child(unsigned int a1)
{
  g_child_pid = a1;
  if ( ptrace(PTRACE_ATTACH, a1, 0LL, 0LL) == -1 )
  {
    kill(g_child_pid, 9);
    exit(-1);
  }
  return get_mapped_start_addr_from_proc_self_maps();
}

//----- (0000000000001B6B) ----------------------------------------------------
__int64 __fastcall BREAKPOINT_add_new(__int64 a1)
{
  return BREAKPOINT_add_new_with_cb(a1, 0LL, 0LL, 0LL);
}

//----- (0000000000001B95) ----------------------------------------------------
__int64 __fastcall BREAKPOINT_add_new_with_cb(__int64 a1, __int64 a2, char *a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 result; // rax
  char *v6; // [rsp+0h] [rbp-50h]
  char *s; // [rsp+8h] [rbp-48h]
  __int64 v8; // [rsp+18h] [rbp-38h]
  _BYTE *v9; // [rsp+28h] [rbp-28h]
  __int64 v10; // [rsp+30h] [rbp-20h]
  __int64 k; // [rsp+38h] [rbp-18h]
  _BYTE *j; // [rsp+40h] [rbp-10h]
  _BYTE *i; // [rsp+48h] [rbp-8h]

  s = a3;
  v8 = g_mapped_start_addr + a1;
  v10 = ptrace(PTRACE_PEEKTEXT, (unsigned int)g_child_pid, g_mapped_start_addr + a1, 0LL, a4);
  if ( v10 == -1 )
  {
    printf("K %p\n", v8);
    kill(g_child_pid, 9);
    exit(-1);
  }
  v9 = malloc(0x38uLL);
  *(_QWORD *)v9 = v8;
  v9[8] = v10;
  *((_QWORD *)v9 + 2) = a2;
  *((_QWORD *)v9 + 6) = 0LL;
  *((_QWORD *)v9 + 5) = -1LL;
  if ( s && *s )
  {
    *((_QWORD *)v9 + 3) = strdup(s);
    for ( i = (_BYTE *)*((_QWORD *)v9 + 3); *i; ++i )
    {
      if ( *i == 10 )
      {
        *i = 0;
        break;
      }
    }
  }
  else
  {
    *((_QWORD *)v9 + 3) = 0LL;
  }
  if ( v6 && *v6 )
  {
    *((_QWORD *)v9 + 4) = strdup(v6);
    for ( j = (_BYTE *)*((_QWORD *)v9 + 4); *j; ++j )
    {
      if ( *j == 10 )
      {
        *j = 0;
        break;
      }
    }
  }
  else
  {
    *((_QWORD *)v9 + 4) = 0LL;
  }
  if ( *((_QWORD *)v9 + 3) || *((_QWORD *)v9 + 4) )
    *((_QWORD *)v9 + 5) = 33LL;
  if ( g_breakpoint_list )
  {
    for ( k = g_breakpoint_list; *(_QWORD *)(k + 48); k = *(_QWORD *)(k + 48) )
      ;
    *(_QWORD *)(k + 48) = v9;
  }
  else
  {
    g_breakpoint_list = v9;
  }
  v4 = v10;
  LOBYTE(v4) = -52;
  result = ptrace(PTRACE_POKETEXT, (unsigned int)g_child_pid, v8, v4);
  if ( result == -1 )
  {
    kill(g_child_pid, 9);
    exit(-1);
  }
  return result;
}
// 20B4B8: using guessed type __int64 g_mapped_start_addr;

//----- (0000000000001DFF) ----------------------------------------------------
void __fastcall BREAKPOINT_reset_entry(__int64 a1, char a2)
{
  char v2; // [rsp+10h] [rbp-50h]
  __int64 v3; // [rsp+40h] [rbp-20h]
  _QWORD *v4; // [rsp+50h] [rbp-10h]
  void *ptr; // [rsp+58h] [rbp-8h]

  if ( g_breakpoint_list )
  {
    memset(&v2, 0, 0x38uLL);
    v3 = g_breakpoint_list;
    ptr = &v2;
    v4 = 0LL;
    while ( ptr && *(_QWORD *)ptr != a1 )
    {
      v4 = ptr;
      ptr = (void *)*((_QWORD *)ptr + 6);
    }
    if ( ptr )
    {
      v4[6] = *((_QWORD *)ptr + 6);
      if ( ptr == (void *)g_breakpoint_list )
        g_breakpoint_list = *((_QWORD *)ptr + 6);
      if ( a2 )
        write_child_mem(*(_QWORD *)ptr, 1, (__int64)ptr + 8);
      free(*((void **)ptr + 3));
      *((_QWORD *)ptr + 3) = 0LL;
      free(*((void **)ptr + 4));
      *((_QWORD *)ptr + 4) = 0LL;
      free(ptr);
    }
  }
}

//----- (0000000000001F2F) ----------------------------------------------------
void __fastcall BREAKPOINT_reset_entry_with_offset(__int64 a1, char a2)
{
  BREAKPOINT_reset_entry(g_mapped_start_addr + a1, a2);
}
// 20B4B8: using guessed type __int64 g_mapped_start_addr;

//----- (0000000000001F5F) ----------------------------------------------------
__int64 __fastcall BREAKPONT_remove_bp_in_child_zone(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  unsigned __int64 v3; // [rsp+10h] [rbp-10h]
  __int64 *v4; // [rsp+18h] [rbp-8h]

  v4 = (__int64 *)g_breakpoint_list;
  result = g_mapped_start_addr + a1;
  v3 = g_mapped_start_addr + a1;
  while ( v4 )
  {
    if ( *v4 >= v3 && *v4 < v3 + a2 )
      write_child_mem(*v4, 1, (__int64)(v4 + 1));
    result = v4[6];
    v4 = (__int64 *)v4[6];
  }
  return result;
}
// 20B4B8: using guessed type __int64 g_mapped_start_addr;

//----- (0000000000001FE7) ----------------------------------------------------
__int64 __fastcall BREAKPONT_restore_bp_in_child_zone(__int64 a1, __int64 a2, char a3)
{
  __int64 result; // rax
  _BYTE *v4; // rax
  char v5; // [rsp+Ch] [rbp-34h]
  unsigned __int64 v6; // [rsp+30h] [rbp-10h]
  __int64 v7; // [rsp+38h] [rbp-8h]

  v5 = a3;
  v7 = g_breakpoint_list;
  result = g_mapped_start_addr + a1;
  v6 = g_mapped_start_addr + a1;
  while ( v7 )
  {
    if ( *(_QWORD *)v7 >= v6 && *(_QWORD *)v7 < v6 + a2 )
    {
      if ( v5 )
      {
        v4 = read_child_mem(*(_QWORD *)v7, 1);
        *(_BYTE *)(v7 + 8) = *v4;
        free(v4);
      }
      write_child_mem(*(_QWORD *)v7, 1, (__int64)&unk_8612);
    }
    result = *(_QWORD *)(v7 + 48);
    v7 = *(_QWORD *)(v7 + 48);
  }
  return result;
}
// 20B4B8: using guessed type __int64 g_mapped_start_addr;

//----- (00000000000020BA) ----------------------------------------------------
__int64 __fastcall BREAKPOINT_set_orginal_byte_with_child_offset(__int64 a1, char a2)
{
  __int64 result; // rax
  __int64 i; // [rsp+14h] [rbp-8h]

  result = g_breakpoint_list;
  for ( i = g_breakpoint_list; i; i = *(_QWORD *)(i + 48) )
  {
    if ( *(_QWORD *)i == g_mapped_start_addr + a1 )
    {
      result = i;
      *(_BYTE *)(i + 8) = a2;
      return result;
    }
    result = *(_QWORD *)(i + 48);
  }
  return result;
}
// 20B4B8: using guessed type __int64 g_mapped_start_addr;

//----- (0000000000002114) ----------------------------------------------------
__int64 __fastcall BREAKPOINT_handle_SIGTRAP_breakpoint(__int64 a1)
{
  __int64 result; // rax
  char dest[8]; // [rsp+10h] [rbp-40h]
  __int64 v3; // [rsp+18h] [rbp-38h]
  __int64 v4; // [rsp+20h] [rbp-30h]
  __int64 v5; // [rsp+28h] [rbp-28h]
  void *ptr; // [rsp+30h] [rbp-20h]
  void (__fastcall *v7)(__int64); // [rsp+38h] [rbp-18h]
  char v8; // [rsp+47h] [rbp-9h]
  __int64 i; // [rsp+48h] [rbp-8h]

  result = g_breakpoint_list;
  for ( i = g_breakpoint_list; i; i = *(_QWORD *)(i + 48) )
  {
    result = *(_QWORD *)i;
    if ( *(_QWORD *)i == a1 - 1 )
      break;
    result = *(_QWORD *)(i + 48);
  }
  if ( i )
  {
    if ( *(_QWORD *)(i + 16) )
    {
      v7 = (void (__fastcall *)(__int64))(*(_QWORD *)(i + 16) + g_mapped_start_addr);
      v7(a1 - g_mapped_start_addr - 1);
    }
    if ( *(_QWORD *)(i + 24) )
    {
      RUN_block_by_name(*(const char **)(i + 24));
      if ( *(_QWORD *)(i + 40) != -1LL )
        --*(_QWORD *)(i + 40);
    }
    if ( !*(_QWORD *)(i + 40) )
    {
      *(_QWORD *)dest = 0LL;
      v3 = 0LL;
      v4 = 0LL;
      v5 = 0LL;
      v8 = 0;
      if ( *(_QWORD *)(i + 32) )
      {
        strncpy(dest, *(const char **)(i + 32), 0x20uLL);
        v8 = 1;
      }
      BREAKPOINT_reset_entry(*(_QWORD *)i, 1);
      if ( v8 )
        RUN_block_by_name(dest);
      ptr = CHILD__get_user_regs_struct();
      --*((_QWORD *)ptr + 16);
      CHILD__set_user_regs_struct((__int64)ptr);
      free(ptr);
    }
    result = BREAKPOINT_run_as_if_triggered_with_CHILD_rip(0);
  }
  return result;
}
// 20B4B8: using guessed type __int64 g_mapped_start_addr;

//----- (00000000000022B7) ----------------------------------------------------
__int64 __fastcall BREAKPOINT_run_as_if_triggered_with_CHILD_rip(char a1)
{
  __int64 v1; // rax
  __int64 result; // rax
  char v3; // [rsp+Ch] [rbp-104h]
  int stat_loc; // [rsp+1Ch] [rbp-F4h]
  char v5; // [rsp+20h] [rbp-F0h]
  __int64 v6; // [rsp+A0h] [rbp-70h]
  __int64 v7; // [rsp+F8h] [rbp-18h]
  __int64 v8; // [rsp+100h] [rbp-10h]
  _QWORD *i; // [rsp+108h] [rbp-8h]

  v3 = a1;
  ptrace(PTRACE_GETREGS, (unsigned int)g_child_pid, 0LL, &v5);
  for ( i = (_QWORD *)g_breakpoint_list; i && *i != v6 - 1; i = (_QWORD *)i[6] )
    ;
  if ( i )
  {
    --v6;
    if ( ptrace(PTRACE_SETREGS, (unsigned int)g_child_pid, 0LL, &v5) == -1 )
    {
      kill(g_child_pid, 9);
      exit(-1);
    }
    if ( v6 != *i )
    {
      kill(g_child_pid, 9);
      exit(-1);
    }
    v8 = ptrace(PTRACE_PEEKTEXT, (unsigned int)g_child_pid, *i, 0LL);
    if ( v8 == -1 )
    {
      kill(g_child_pid, 9);
      exit(-1);
    }
    if ( (unsigned __int8)v8 == 204LL )
      v3 = 1;
    if ( v3 )
    {
      v1 = v8;
      LOBYTE(v1) = 0;
      v7 = v1 | *((unsigned __int8 *)i + 8);
      if ( ptrace(PTRACE_POKETEXT, (unsigned int)g_child_pid, *i, v7) == -1 )
      {
        kill(g_child_pid, 9);
        exit(-1);
      }
    }
    if ( ptrace(PTRACE_SINGLESTEP, (unsigned int)g_child_pid, 0LL, 0LL) == -1 )
    {
      kill(g_child_pid, 9);
      exit(-1);
    }
    waitpid(g_child_pid, &stat_loc, 0);
    if ( (unsigned __int8)stat_loc != 127 || BYTE1(stat_loc) != 5 )
    {
      kill(g_child_pid, 9);
      exit(-1);
    }
    if ( ptrace(PTRACE_POKETEXT, (unsigned int)g_child_pid, *i, v8) == -1 )
    {
      kill(g_child_pid, 9);
      exit(-1);
    }
    result = ptrace(PTRACE_CONT, (unsigned int)g_child_pid, 0LL, 0LL);
    if ( result == -1 )
    {
      kill(g_child_pid, 9);
      exit(-1);
    }
  }
  else
  {
    result = ptrace(PTRACE_CONT, (unsigned int)g_child_pid, 0LL, 0LL);
    if ( result == -1 )
    {
      kill(g_child_pid, 9);
      exit(-1);
    }
  }
  return result;
}

//----- (00000000000025E4) ----------------------------------------------------
_BYTE *__fastcall read_child_mem_by_offset(__int64 a1, int a2)
{
  return read_child_mem(a1 + g_mapped_start_addr, a2);
}
// 20B4B8: using guessed type __int64 g_mapped_start_addr;

//----- (0000000000002610) ----------------------------------------------------
_BYTE *__fastcall read_child_mem(__int64 a1, int a2)
{
  int i; // [rsp+4h] [rbp-2Ch]
  __int64 v4; // [rsp+10h] [rbp-20h]
  _BYTE *v5; // [rsp+20h] [rbp-10h]
  int j; // [rsp+2Ch] [rbp-4h]

  for ( i = a2; i & 7; ++i )
    ;
  v5 = malloc(i);
  for ( j = 0; j < i; j += 8 )
  {
    v4 = ptrace(PTRACE_PEEKTEXT, (unsigned int)g_child_pid, a1 + j, 0LL);
    if ( v4 == -1 )
    {
      kill(g_child_pid, 9);
      exit(-1);
    }
    *(_WORD *)&v5[j] = v4;
    v5[j + 2] = BYTE2(v4);
    v5[j + 3] = BYTE3(v4);
    v5[j + 4] = BYTE4(v4);
    v5[j + 5] = BYTE5(v4);
    v5[j + 6] = BYTE6(v4);
    v5[j + 7] = HIBYTE(v4);
  }
  return v5;
}

//----- (000000000000278B) ----------------------------------------------------
__int64 __fastcall CHILD__xor_addr_with_value(__int64 a1, __int64 a2)
{
  __int64 *v2; // rax
  __int64 v4; // [rsp+10h] [rbp-10h]
  void *ptr; // [rsp+18h] [rbp-8h]

  v2 = (__int64 *)read_child_mem_by_offset(a1, 8);
  ptr = v2;
  v4 = *v2;
  free(v2);
  ptr = 0LL;
  v4 ^= a2;
  return write_child_mem_by_offset(a1, 8, (__int64)&v4);
}

//----- (00000000000027F3) ----------------------------------------------------
__int64 __fastcall write_child_mem_by_offset(__int64 a1, int a2, __int64 a3)
{
  return write_child_mem(g_mapped_start_addr + a1, a2, a3);
}
// 20B4B8: using guessed type __int64 g_mapped_start_addr;

//----- (0000000000002829) ----------------------------------------------------
__int64 __fastcall write_child_mem(__int64 a1, int a2, __int64 a3)
{
  unsigned __int64 v3; // ST40_8
  _BYTE *v4; // rax
  __int64 result; // rax
  __int64 v6; // [rsp+8h] [rbp-58h]
  unsigned int i; // [rsp+54h] [rbp-Ch]
  __int64 v8; // [rsp+58h] [rbp-8h]

  v6 = a3;
  for ( i = 0; ; i += 8 )
  {
    result = i;
    if ( (signed int)i >= a2 )
      break;
    v3 = (signed int)(a2 - i);
    if ( v3 > 7 )
    {
      v8 = *(_QWORD *)((signed int)i + v6);
    }
    else
    {
      v4 = read_child_mem((signed int)i + a1, 8);
      v8 = (*(_QWORD *)((signed int)i + v6) << (-8 * ((unsigned __int8)a2 - (unsigned __int8)i) + 64) >> (-8 * ((unsigned __int8)a2 - (unsigned __int8)i) + 64)) | (*(_QWORD *)v4 >> 8 * ((unsigned __int8)a2 - (unsigned __int8)i) << 8 * ((unsigned __int8)a2 - (unsigned __int8)i));
      free(v4);
    }
    if ( ptrace(PTRACE_POKETEXT, (unsigned int)g_child_pid, (signed int)i + a1, v8) == -1 )
    {
      kill(g_child_pid, 9);
      exit(-1);
    }
  }
  return result;
}

//----- (0000000000002990) ----------------------------------------------------
void __fastcall CHILD__memcpy(__int64 a1, int a2, __int64 a3)
{
  _BYTE *ptr; // ST28_8

  ptr = read_child_mem_by_offset(a3, a2);
  write_child_mem_by_offset(a1, a2, (__int64)ptr);
  free(ptr);
}

//----- (00000000000029EB) ----------------------------------------------------
void __fastcall CHILD__hexdump_mem(int a1, int a2)
{
  __int64 v2; // [rsp+18h] [rbp-18h]
  _BYTE *ptr; // [rsp+20h] [rbp-10h]
  int i; // [rsp+2Ch] [rbp-4h]

  ptr = read_child_mem_by_offset(a1, a2);
  v2 = a1 + g_mapped_start_addr;
  printf("[%016lx] ", v2);
  for ( i = 0; i < a2; ++i )
  {
    printf("%02X ", (unsigned __int8)ptr[i]);
    if ( i % 16 == 7 )
    {
      printf("  ");
    }
    else if ( i % 16 == 15 )
    {
      printf("\n[%016lx] ", i + v2);
    }
  }
  putchar(10);
  free(ptr);
}
// 20B4B8: using guessed type __int64 g_mapped_start_addr;

//----- (0000000000002AF8) ----------------------------------------------------
void *CHILD__get_user_regs_struct()
{
  void *v0; // ST08_8

  v0 = malloc(0xD8uLL);
  ptrace(PTRACE_GETREGS, (unsigned int)g_child_pid, 0LL, v0);
  return v0;
}

//----- (0000000000002B37) ----------------------------------------------------
__int64 __fastcall CHILD__set_user_regs_struct(__int64 a1)
{
  __int64 result; // rax

  result = ptrace(PTRACE_SETREGS, (unsigned int)g_child_pid, 0LL, a1);
  if ( result == -1 )
  {
    kill(g_child_pid, 9);
    exit(-1);
  }
  return result;
}

//----- (0000000000002B90) ----------------------------------------------------
void __fastcall CHILD__flip_ZF_if_0x7A(char a1)
{
  _QWORD *ptr; // [rsp+18h] [rbp-8h]

  ptr = CHILD__get_user_regs_struct();
  if ( a1 == 122 )
    ptr[18] ^= 0x40uLL;
  CHILD__set_user_regs_struct((__int64)ptr);
  free(ptr);
}

//----- (0000000000002BEC) ----------------------------------------------------
__int64 __fastcall CHILD__get_reg_value(const char *a1)
{
  _QWORD *ptr; // [rsp+10h] [rbp-10h]
  __int64 v3; // [rsp+18h] [rbp-8h]

  ptr = CHILD__get_user_regs_struct();
  v3 = 0LL;
  if ( !strcmp(a1, "eax") )
  {
    v3 = (unsigned int)ptr[10];
  }
  else if ( !strcmp(a1, "ebx") )
  {
    v3 = (unsigned int)ptr[5];
  }
  else if ( !strcmp(a1, "ecx") )
  {
    v3 = (unsigned int)ptr[11];
  }
  else if ( !strcmp(a1, "edx") )
  {
    v3 = (unsigned int)ptr[12];
  }
  else if ( !strcmp(a1, "edi") )
  {
    v3 = (unsigned int)ptr[14];
  }
  else if ( !strcmp(a1, "esi") )
  {
    v3 = (unsigned int)ptr[13];
  }
  else if ( !strcmp(a1, "ebp") )
  {
    v3 = (unsigned int)ptr[4];
  }
  else if ( !strcmp(a1, "esp") )
  {
    v3 = (unsigned int)ptr[19];
  }
  else if ( !strcmp(a1, "eip") )
  {
    v3 = (unsigned int)ptr[16];
  }
  else if ( !strcmp(a1, "rax") )
  {
    v3 = ptr[10];
  }
  else if ( !strcmp(a1, "rbx") )
  {
    v3 = ptr[5];
  }
  else if ( !strcmp(a1, "rcx") )
  {
    v3 = ptr[11];
  }
  else if ( !strcmp(a1, "rdx") )
  {
    v3 = ptr[12];
  }
  else if ( !strcmp(a1, "rdi") )
  {
    v3 = ptr[14];
  }
  else if ( !strcmp(a1, "rsi") )
  {
    v3 = ptr[13];
  }
  else if ( !strcmp(a1, "rbp") )
  {
    v3 = ptr[4];
  }
  else if ( !strcmp(a1, "rsp") )
  {
    v3 = ptr[19];
  }
  else if ( !strcmp(a1, "rip") )
  {
    v3 = ptr[16];
  }
  free(ptr);
  return v3;
}

//----- (0000000000002F0C) ----------------------------------------------------
void __fastcall CHILD__set_reg_value(const char *a1, __int64 a2)
{
  _QWORD *ptr; // [rsp+18h] [rbp-8h]

  ptr = CHILD__get_user_regs_struct();
  if ( !strcmp(a1, "eax") || !strcmp(a1, "rax") )
  {
    ptr[10] = a2;
  }
  else if ( !strcmp(a1, "ebx") || !strcmp(a1, "rbx") )
  {
    ptr[5] = a2;
  }
  else if ( !strcmp(a1, "ecx") || !strcmp(a1, "rcx") )
  {
    ptr[11] = a2;
  }
  else if ( !strcmp(a1, "edx") || !strcmp(a1, "rdx") )
  {
    ptr[12] = a2;
  }
  else if ( !strcmp(a1, "edi") || !strcmp(a1, "rdi") )
  {
    ptr[14] = a2;
  }
  else if ( !strcmp(a1, "ebp") || !strcmp(a1, "rbp") )
  {
    ptr[4] = a2;
  }
  else if ( !strcmp(a1, "esi") || !strcmp(a1, "rsi") )
  {
    ptr[13] = a2;
  }
  else if ( !strcmp(a1, "esp") || !strcmp(a1, "rsp") )
  {
    ptr[19] = a2;
  }
  else if ( !strcmp(a1, "eip") || !strcmp(a1, "rip") )
  {
    ptr[16] = a2;
  }
  CHILD__set_user_regs_struct((__int64)ptr);
  free(ptr);
}

//----- (000000000000317A) ----------------------------------------------------
__int64 __fastcall file_process_begin__load_function(const char *a1, FILE *a2)
{
  size_t n; // [rsp+18h] [rbp-48h]
  char *s2; // [rsp+20h] [rbp-40h]
  char s1[4]; // [rsp+2Ch] [rbp-34h]
  char *v6; // [rsp+30h] [rbp-30h]
  char *dest; // [rsp+38h] [rbp-28h]
  __int64 i; // [rsp+40h] [rbp-20h]
  char *v9; // [rsp+48h] [rbp-18h]
  unsigned __int8 v10; // [rsp+57h] [rbp-9h]
  char *src; // [rsp+58h] [rbp-8h]

  dest = (char *)calloc(1uLL, 0x50uLL);
  strcpy(s1, "end");
  src = strrchr(a1, 32) + 1;
  strncpy(dest, src, 0x40uLL);
  for ( src = dest; *src; ++src )
  {
    if ( *src == 10 )
      *src = 0;
  }
  dest[63] = 0;
  s2 = 0LL;
  v10 = 0;
  v9 = dest + 64;
  while ( getline(&s2, &n, a2) != -1 )
  {
    if ( !strncmp(s1, s2, 3uLL) )
    {
      v10 = 1;
      break;
    }
    v6 = (char *)calloc(1uLL, 0x108uLL);
    strncpy(v6, s2, 0x108uLL);
    *(_QWORD *)v9 = v6;
    v9 = v6 + 256;
    if ( s2 )
    {
      free(s2);
      s2 = 0LL;
      n = 0LL;
    }
  }
  if ( v10 )
  {
    if ( g_pBlocks )
    {
      for ( i = g_pBlocks; *(_QWORD *)(i + 72); i = *(_QWORD *)(i + 72) )
        ;
      *(_QWORD *)(i + 72) = dest;
    }
    else
    {
      g_pBlocks = dest;
    }
  }
  return v10;
}

//----- (000000000000333D) ----------------------------------------------------
__int64 __fastcall RUN_block_by_name(const char *a1)
{
  __int64 result; // rax
  __int64 i; // [rsp+10h] [rbp-10h]
  char *s2; // [rsp+18h] [rbp-8h]

  result = g_pBlocks;
  for ( s2 = (char *)g_pBlocks; s2; s2 = (char *)*((_QWORD *)s2 + 9) )
  {
    if ( !strcmp(a1, s2) )
    {
      result = *((_QWORD *)s2 + 8);
      for ( i = *((_QWORD *)s2 + 8); i; i = *(_QWORD *)(i + 256) )
      {
        RUN_line((char *)i);
        result = *(_QWORD *)(i + 256);
      }
      return result;
    }
    result = *((_QWORD *)s2 + 9);
  }
  return result;
}

//----- (00000000000033B8) ----------------------------------------------------
void __fastcall CHILD__emulate_call_with_child_offset(__int64 a1)
{
  __int64 v1; // [rsp+10h] [rbp-10h]
  void *ptr; // [rsp+18h] [rbp-8h]

  ptr = CHILD__get_user_regs_struct();
  *((_QWORD *)ptr + 19) -= 8LL;
  v1 = *((_QWORD *)ptr + 16) + 4LL;
  *((_QWORD *)ptr + 16) = a1 + g_mapped_start_addr;
  CHILD__set_user_regs_struct((__int64)ptr);
  write_child_mem(*((_QWORD *)ptr + 19), 8, (__int64)&v1);
  free(ptr);
}
// 20B4B8: using guessed type __int64 g_mapped_start_addr;

//----- (0000000000003452) ----------------------------------------------------
void CHILD__emulate_ret()
{
  _QWORD *v0; // ST08_8
  _BYTE *ptr; // ST00_8

  v0 = CHILD__get_user_regs_struct();
  ptr = read_child_mem(v0[19], 8);
  v0[19] += 8LL;
  v0[16] = *(_QWORD *)ptr;
  CHILD__set_user_regs_struct((__int64)v0);
  free(ptr);
  free(v0);
}

//----- (00000000000034E2) ----------------------------------------------------
__int64 __fastcall get_child_offset_from_addr(__int64 a1)
{
  return a1 - g_mapped_start_addr;
}
// 20B4B8: using guessed type __int64 g_mapped_start_addr;

//----- (00000000000034FD) ----------------------------------------------------
char *__fastcall transform_4bytes_into_3bytes_key_using_CRYPTO(__int64 a1)
{
  char *ptr; // [rsp+10h] [rbp-10h]
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i <= 0x1F3; ++i )
  {
    ptr = crypto_encrypt_xorStreamCipher((__int64)&unk_8680 + 3 * i, 3, a1, 4);
    if ( !strncmp(ptr + 1, asc_8C5C, 3uLL) )
      return (char *)&unk_8680 + 3 * i;
    free(ptr);
  }
  return 0LL;
}

//----- (00000000000035B1) ----------------------------------------------------
__int64 __fastcall decrypt_a_function(__int64 a1)
{
  _QWORD *ptr; // ST30_8
  int v2; // eax
  __int64 v4; // [rsp+8h] [rbp-58h]
  void **v5; // [rsp+20h] [rbp-40h]
  _BYTE *v6; // [rsp+28h] [rbp-38h]
  signed int m; // [rsp+3Ch] [rbp-24h]
  signed int l; // [rsp+40h] [rbp-20h]
  signed int i; // [rsp+44h] [rbp-1Ch]
  char *v10; // [rsp+48h] [rbp-18h]
  int v11; // [rsp+54h] [rbp-Ch]
  signed int j; // [rsp+58h] [rbp-8h]
  signed int k; // [rsp+58h] [rbp-8h]
  signed int v14; // [rsp+5Ch] [rbp-4h]

  v4 = a1;
  v14 = -1;
  v11 = 0;
  for ( i = 0; i <= 55; ++i )
  {
    if ( g_level2_breakpoint_end_offsets[i] == a1 )
    {
      v14 = i;
      v4 = g_level2_breakpoint_offsets_of_decrypted_fct[i];
      break;
    }
  }
  if ( v14 == -1 )
  {
    for ( j = 0; j <= 55 && g_level2_breakpoint_hitCounts_offset[j] != v4 && g_level2_breakpoint_hitCounts_offset[j]; ++j )
      ;
    if ( g_level2_breakpoint_hitCounts_max_2[j] > 2 )
      return 0LL;
    g_level2_breakpoint_hitCounts_offset[j] = v4;
    ++g_level2_breakpoint_hitCounts_max_2[j];
  }
  else
  {
    for ( k = 0; k <= 55 && g_level2_breakpoint_hitCounts_offset[k] != v4; ++k )
      ;
    if ( k != 56 && g_level2_breakpoint_hitCounts_max_2[k] > 2 )
    {
      BREAKPOINT_reset_entry_with_offset(v4, 1);
      BREAKPOINT_reset_entry_with_offset(g_level2_breakpoint_end_offsets[v14], 1);
      ptr = CHILD__get_user_regs_struct();
      --ptr[16];
      CHILD__set_user_regs_struct((__int64)ptr);
      free(ptr);
      return 0LL;
    }
  }
  BREAKPONT_remove_bp_in_child_zone(v4, 4096LL);
  v6 = read_child_mem_by_offset(v4, 4096);
  if ( v14 == -1 )
  {
    v10 = transform_4bytes_into_3bytes_key_using_CRYPTO((__int64)v6);
    if ( !v10 )
      exit(1);
  }
  else
  {
    v2 = rand();
    v10 = (char *)&unk_8680
        + 3 * (signed int)((unsigned __int8)(((unsigned int)(v2 >> 31) >> 24) + v2) - ((unsigned int)(v2 >> 31) >> 24));
  }
  v5 = (void **)crypto_keySchedule((__int64)v10, 3);
  for ( l = 0; ; ++l )
  {
    v6[l] ^= crypto_getByteStream((__int64)v5);
    if ( v14 != -1 )
    {
      if ( l + v4 == g_level2_breakpoint_end_offsets[v14] )
        break;
      continue;
    }
    if ( v6[l] == -112 && l > 2 && v6[l - 1] == -112 && v6[l - 2] != -112 )
    {
      ++v11;
      continue;
    }
    if ( v11 == 1 && v6[l] == -61 )
      break;
  }
  if ( v14 == -1 )
  {
    *v6 = 85;
    for ( m = 0; m <= 55; ++m )
    {
      if ( !g_level2_breakpoint_offsets_of_decrypted_fct[m] )
      {
        g_level2_breakpoint_offsets_of_decrypted_fct[m] = v4;
        g_level2_breakpoint_end_offsets[m] = l + v4;
        break;
      }
    }
  }
  else
  {
    g_level2_breakpoint_offsets_of_decrypted_fct[v14] = 0LL;
    g_level2_breakpoint_end_offsets[v14] = 0LL;
  }
  write_child_mem_by_offset(v4, l + 1, (__int64)v6);
  BREAKPONT_restore_bp_in_child_zone(v4, 4096LL, 1);
  crypto_free_state(v5);
  free(v6);
  if ( v14 != -1 )
    CHILD__emulate_ret();
  return 0LL;
}

//----- (0000000000003A64) ----------------------------------------------------
_DWORD *__fastcall BITMAP_get_next_transparent_pixel_PTR_y_x(BITMAP *bmp, unsigned int *py, _DWORD *px)
{
  _DWORD *result; // rax
  unsigned int j; // [rsp+24h] [rbp-14h]
  unsigned int i; // [rsp+28h] [rbp-10h]
  bool v6; // [rsp+2Fh] [rbp-9h]
  struct TRANSPARENT_PT_LIST *v7_pTransparent; // [rsp+30h] [rbp-8h]

  v7_pTransparent = bmp->pTransparentPts_Head;
  do
  {
    if ( !v7_pTransparent )
      break;
    if ( v7_pTransparent->y >= *py
      && (v7_pTransparent->y != *py || v7_pTransparent->x >= *px)
      && v7_pTransparent->x + 448 < bmp->dwWidth
      && v7_pTransparent->y + 56 <= bmp->dwHeight )
    {
      v6 = 1;
      for ( i = v7_pTransparent->x; v7_pTransparent->x + 448 > i; ++i )
        v6 = ((((v6 && bmp->pPixels[v7_pTransparent->y][i] == 0) != 0 && bmp->pPixels[v7_pTransparent->y + 1][i] == 0) != 0
            && bmp->pPixels[v7_pTransparent->y + 55][i] == 0) != 0
           && bmp->pPixels[v7_pTransparent->y + 54][i] == 0) != 0;
      for ( j = v7_pTransparent->y; v7_pTransparent->y + 56 > j; ++j )
        v6 = ((v6 && bmp->pPixels[j][v7_pTransparent->x] == 0) != 0 && bmp->pPixels[j][v7_pTransparent->x + 1] == 0) != 0;
      if ( v6 )
      {
        *py = v7_pTransparent->y;
        result = px;
        *px = v7_pTransparent->x;
        return result;
      }
    }
    v7_pTransparent = v7_pTransparent->pNext;
  }
  while ( v7_pTransparent->pNext != bmp->pTransparentPts_Head );
  *py = bmp->dwHeight;
  result = px;
  *px = bmp->dwWidth;
  return result;
}

//----- (0000000000003D2C) ----------------------------------------------------
char __fastcall ENC_PART_maybe_match_bitmap__internal(ENC_PART *part, BITMAP *bmp)
{
  float v3_score; // [rsp+1Ch] [rbp-14h]
  ENC_TYPE_I_SUB *pResult; // [rsp+20h] [rbp-10h]
  char v5; // [rsp+2Fh] [rbp-1h]

  v3_score = *(float *)a5.m128i_i32;
  ENC_PART_recursive_compure_score(part, bmp, &pResult, &v3_score, (__m128i)a5.m128i_u32[0]);
  if ( v3_score <= 2500000.0 )
    v5 = pResult->byte_from_file;
  else
    v5 = '!';
  return v5;
}

//----- (0000000000003DA9) ----------------------------------------------------
__int64 __fastcall ENC_PART_maybe_match_bitmap(ENC_PART *a1, BITMAP *a2)
{
  return (unsigned __int8)ENC_PART_maybe_match_bitmap__internal(a1, a2);
}

//----- (0000000000003DF8) ----------------------------------------------------
__int64 __fastcall BITMAP_is_croppedsquare_seems_good(BITMAP *a1, unsigned int a2, int a3, unsigned int a4, int a5, unsigned int a6)
{
  bool v6; // al
  unsigned __int8 v8; // [rsp+2Bh] [rbp-1h]
  void *retaddr[2]; // [rsp+34h] [rbp+8h]

  v8 = 1;
  v6 = a3 && a1->dwHeight - 1 > a4 && a5 && a1->dwWidth - 1 > a6;
  *(_BYTE *)retaddr[1] = v6;
  if ( a2 <= 0x31 || a2 > 0x190 )
    v8 = 0;
  if ( *(_BYTE *)retaddr[1] != 1 )
    v8 = 0;
  return v8;
}

//----- (0000000000003EA2) ----------------------------------------------------
__int64 __fastcall sub_3EA2(__int64 a1)
{
  unsigned int j; // [rsp+Ch] [rbp-Ch]
  __int64 i; // [rsp+10h] [rbp-8h]

  for ( i = (unsigned int)(*(_DWORD *)(a1 + 24) - 1); (_DWORD)i; LODWORD(i) = i - 1 )
  {
    for ( j = 0; *(_DWORD *)(a1 + 20) > j; ++j )
    {
      if ( *(_BYTE *)(*(_QWORD *)(8LL * j + *(_QWORD *)a1) + (unsigned int)i) )
      {
        HIDWORD(i) = i;
        return HIDWORD(i);
      }
    }
  }
  return HIDWORD(i);
}

//----- (0000000000003F34) ----------------------------------------------------
BITMAP *__fastcall BITMAP_crop_0x38square_and_extract_filled_pt_with_dezoom2(BITMAP *bmp, unsigned int ypos, unsigned int xpos, _DWORD *pNumberFullPixels, __int64 pYmax, __int64 pYmin, __int64 pXmax, __int64 pXmin)
{
  unsigned int *v8; // ST10_8
  unsigned int *v9; // ST08_8
  BITMAP *v10_new_bmp; // ST48_8
  BITMAP *v11; // ST40_8
  BITMAP *v12; // ST38_8

  v8 = (unsigned int *)pYmax;
  v9 = (unsigned int *)pYmin;
  v10_new_bmp = BITMAP_crop_yxhw(bmp, ypos, xpos, 0x38u, 0x38u, pNumberFullPixels);
  v11 = BITMAP_crop_around_filled_pixels_and_give_YX_maxmin(
          v10_new_bmp,
          v8,
          v9,
          (unsigned int *)pXmax,
          (unsigned int *)pXmin);
  BITMAP_free(v10_new_bmp);
  v12 = BITMAP_shrink_with_scale(v11, 2u);
  BITMAP_free(v11);
  return v12;
}

//----- (0000000000003FF3) ----------------------------------------------------
char *__fastcall ENC_PART_do_OCR_text_on_screenshot(ENC_PART *parts, BITMAP *screenshot)
{
  unsigned int v4_ymin; // [rsp+14h] [rbp-3Ch]
  unsigned int v5_ymax; // [rsp+18h] [rbp-38h]
  unsigned int v6_xmin; // [rsp+1Ch] [rbp-34h]
  unsigned int v7_xmax; // [rsp+20h] [rbp-30h]
  unsigned int v8_number_of_fullPixels; // [rsp+24h] [rbp-2Ch]
  char v8; // [rsp+2Bh] [rbp-25h]
  unsigned int v_x; // [rsp+2Ch] [rbp-24h]
  unsigned int v_y; // [rsp+30h] [rbp-20h]
  char v11_read_char; // [rsp+37h] [rbp-19h]
  BITMAP *v_bmp; // [rsp+38h] [rbp-18h]
  unsigned int v13_posText; // [rsp+44h] [rbp-Ch]
  char *pszInputText; // [rsp+48h] [rbp-8h]

  v_y = 0;
  v_x = 0;
  pszInputText = (char *)malloc(9uLL);
  pszInputText[8] = 0;
  v13_posText = 0;
  BITMAP_get_next_transparent_pixel_PTR_y_x(screenshot, &v_y, &v_x);
  while ( screenshot->dwHeight - 56 > v_y && screenshot->dwWidth - 56 > v_x && v13_posText != 8 )
  {
    v_bmp = BITMAP_crop_0x38square_and_extract_filled_pt_with_dezoom2(
              screenshot,
              v_y,
              v_x,
              &v8_number_of_fullPixels,
              (__int64)&v5_ymax,
              (__int64)&v4_ymin,
              (__int64)&v7_xmax,
              (__int64)&v6_xmin);
    if ( (unsigned __int8)BITMAP_is_croppedsquare_seems_good(
                            v_bmp,
                            v8_number_of_fullPixels >> 2,
                            v5_ymax >> 1,
                            v4_ymin >> 1,
                            v7_xmax >> 1,
                            v6_xmin >> 1) )
    {
      v11_read_char = ENC_PART_maybe_match_bitmap(parts, v_bmp);
      if ( v11_read_char != '!' )
        pszInputText[v13_posText++] = v11_read_char;
    }
    if ( v8 )
    {
      v_x += 55;
    }
    else if ( v7_xmax > 3 )
    {
      v_x = v7_xmax + v_x - 2;
    }
    else
    {
      v_x += v6_xmin;
    }
    if ( v_x + 56 >= screenshot->dwWidth )
    {
      BITMAP_get_next_transparent_pixel_PTR_y_x(screenshot, &v_y, &v_x);
      v13_posText = 0;
      break;
    }
    BITMAP_free(v_bmp);
  }
  if ( v13_posText <= 7 )
  {
    free(pszInputText);
    pszInputText = 0LL;
  }
  return pszInputText;
}

//----- (00000000000041E3) ----------------------------------------------------
ENC_TYPE_I_SUB *__fastcall ENCDATA_load_part_I_subpart_rectangle_bytes_with_attr(FILE *file)
{
  ENC_TYPE_I_SUB *v2; // [rsp+10h] [rbp-10h]
  signed int i; // [rsp+1Ch] [rbp-4h]

  v2 = (ENC_TYPE_I_SUB *)malloc(0x10uLL);
  fread(&v2->byte_from_file, 1uLL, 1uLL, file);
  for ( i = 0; !i; i = 1 )
    LOBYTE(v2->byte_from_file) ^= crypto_getByteStream((__int64)g_p_crypto_state_of_child);
  v2->pBmp = ENCDATA_load_rectangle_bytes(file);
  return v2;
}

//----- (00000000000042A4) ----------------------------------------------------
void __fastcall sub_42A4(BITMAP **a1)
{
  BITMAP_free(*a1);
  free(a1);
}

//----- (00000000000042D6) ----------------------------------------------------
_BOOL8 __fastcall is_space(char a1)
{
  return a1 == 32 || a1 == 9 || a1 == 10 || a1 == 13;
}

//----- (0000000000004305) ----------------------------------------------------
void *parse_u64_from_linebuffer_with_static_var()
{
  void *result; // rax
  signed __int64 v1; // [rsp+8h] [rbp-8h]

  v1 = 0LL;
  while ( !(unsigned int)is_space(*g_pszCurrentlyRunningLine__pChar)
       && *g_pszCurrentlyRunningLine__pChar > 47
       && *g_pszCurrentlyRunningLine__pChar <= 57 )
    v1 = 10 * v1 + (char)*g_pszCurrentlyRunningLine__pChar++ - 48;
  result = &g_parser_current_u64_value;
  g_parser_current_u64_value = v1;
  return result;
}

//----- (00000000000043B1) ----------------------------------------------------
void *parse_reg_name_and_get_value()
{
  __int64 v0; // rdx
  void *result; // rax
  signed int i; // [rsp+Ch] [rbp-4h]

  for ( i = 0;
        !(unsigned int)is_space(*g_pszCurrentlyRunningLine__pChar)
     && *g_pszCurrentlyRunningLine__pChar
     && (unsigned int)i <= 7;
        ++i )
  {
    g_current_reg_name[i] = *g_pszCurrentlyRunningLine__pChar++;
  }
  g_current_reg_name[i] = 0;
  v0 = CHILD__get_reg_value(g_current_reg_name);
  result = &g_parser_current_u64_value;
  g_parser_current_u64_value = v0;
  return result;
}

//----- (000000000000445C) ----------------------------------------------------
signed __int64 parse_token_and_return_kind()
{
  __int64 v0; // rax
  signed __int64 result; // rax

  while ( 2 )
  {
    v0 = (unsigned int)(char)*g_pszCurrentlyRunningLine__pChar;
    switch ( (unsigned int)off_8C90 )
    {
      case 0u:
        result = 7LL;
        break;
      case 9u:
      case 0xAu:
      case 0xDu:
      case 0x20u:
        ++g_pszCurrentlyRunningLine__pChar;
        continue;
      case 0x24u:
        ++g_pszCurrentlyRunningLine__pChar;
        parse_reg_name_and_get_value();
        result = 6LL;
        break;
      case 0x28u:
        ++g_pszCurrentlyRunningLine__pChar;
        result = 4LL;
        break;
      case 0x29u:
        ++g_pszCurrentlyRunningLine__pChar;
        result = 5LL;
        break;
      case 0x2Au:
        ++g_pszCurrentlyRunningLine__pChar;
        result = 3LL;
        break;
      case 0x2Bu:
        ++g_pszCurrentlyRunningLine__pChar;
        result = 1LL;
        break;
      case 0x2Du:
        ++g_pszCurrentlyRunningLine__pChar;
        result = 2LL;
        break;
      default:
        parse_u64_from_linebuffer_with_static_var();
        result = 0LL;
        break;
    }
    break;
  }
  return result;
}
// 8C90: using guessed type void *__ptr32 off_8C90[46];

//----- (00000000000045A5) ----------------------------------------------------
unsigned int *__fastcall parse_next_token_given_current_kind(int a1)
{
  unsigned int *result; // rax
  unsigned int v2; // edx

  if ( g_lastTokenKind[0] != a1 )
  {
    kill(pid, 9);
    exit(-1);
  }
  result = (unsigned int *)g_lastTokenKind[0];
  if ( g_lastTokenKind[0] != 7 )
  {
    v2 = parse_token_and_return_kind();
    result = g_lastTokenKind;
    g_lastTokenKind[0] = v2;
  }
  return result;
}

//----- (0000000000004600) ----------------------------------------------------
unsigned int *__fastcall parse_recurr__left_of_minus_star(unsigned int *a1)
{
  unsigned int *result; // rax
  __int64 v2; // [rsp+18h] [rbp-8h]

  switch ( (unsigned int)off_8D48 )
  {
    case 0u:
      *(_QWORD *)a1 = g_parser_current_u64_value;
      result = parse_next_token_given_current_kind(0);
      break;
    case 2u:
      parse_next_token_given_current_kind(2);
      parse_recurr__left_of_minus_star((unsigned int *)&v2);
      result = a1;
      *(_QWORD *)a1 = -v2;
      break;
    case 4u:
      parse_next_token_given_current_kind(4);
      parse_expr__in_parenthesis(a1);
      result = parse_next_token_given_current_kind(5);
      break;
    case 6u:
      *(_QWORD *)a1 = g_parser_current_u64_value;
      result = parse_next_token_given_current_kind(6);
      break;
    case 7u:
      result = a1;
      *(_QWORD *)a1 = 0LL;
      break;
    default:
      kill(pid, 9);
      exit(-1);
      return result;
  }
  return result;
}
// 8D48: using guessed type void *__ptr32 off_8D48[8];

//----- (00000000000046F5) ----------------------------------------------------
__int64 __fastcall parse_recurr__multiplication(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+18h] [rbp-8h]

  if ( g_lastTokenKind[0] == 3 )
  {
    parse_next_token_given_current_kind(3);
    parse_recurr__left_of_minus_star((unsigned int *)&v3);
    result = parse_recurr__multiplication(a1 * v3, a2);
  }
  else
  {
    result = (__int64)a2;
    *a2 = a1;
  }
  return result;
}

//----- (0000000000004752) ----------------------------------------------------
__int64 __fastcall parse_recurr__right_of_plusminus(_QWORD *a1)
{
  __int64 v2; // [rsp+18h] [rbp-8h]

  parse_recurr__left_of_minus_star((unsigned int *)&v2);
  return parse_recurr__multiplication(v2, a1);
}

//----- (0000000000004780) ----------------------------------------------------
__int64 __fastcall parse_recurr__plus(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // [rsp+18h] [rbp-8h]

  if ( g_lastTokenKind[0] == 1 )
  {
    parse_next_token_given_current_kind(1);
    parse_recurr__right_of_plusminus(&v3);
    result = parse_recurr__plus(a1 + v3, a2);
  }
  else if ( g_lastTokenKind[0] == 2 )
  {
    parse_next_token_given_current_kind(2);
    parse_recurr__right_of_plusminus(&v3);
    result = parse_recurr__plus(a1 - v3, a2);
  }
  else
  {
    result = (__int64)a2;
    *a2 = a1;
  }
  return result;
}

//----- (0000000000004818) ----------------------------------------------------
__int64 __fastcall parse_expr__in_parenthesis(_QWORD *a1)
{
  __int64 v2; // [rsp+18h] [rbp-8h]

  parse_recurr__right_of_plusminus(&v2);
  return parse_recurr__plus(v2, a1);
}

//----- (0000000000004846) ----------------------------------------------------
void __fastcall RUN_line(char *a1)
{
  _BYTE *v1; // rbx
  __int64 v2; // [rsp+10h] [rbp-110h]
  __int64 v3; // [rsp+18h] [rbp-108h]
  __int64 v4; // [rsp+20h] [rbp-100h]
  __int64 v5; // [rsp+28h] [rbp-F8h]
  __int64 v6; // [rsp+30h] [rbp-F0h]
  __int64 v7; // [rsp+38h] [rbp-E8h]
  __int64 v8; // [rsp+40h] [rbp-E0h]
  __int64 v9; // [rsp+48h] [rbp-D8h]
  __int64 v10; // [rsp+58h] [rbp-C8h]
  __int128 v11; // [rsp+60h] [rbp-C0h]
  __int64 v12; // [rsp+70h] [rbp-B0h]
  __int128 v13; // [rsp+78h] [rbp-A8h]
  __int64 v14; // [rsp+88h] [rbp-98h]
  __int128 size; // [rsp+90h] [rbp-90h]
  __int128 v16; // [rsp+A0h] [rbp-80h]
  __int64 v17; // [rsp+B0h] [rbp-70h]
  __int64 v18; // [rsp+B8h] [rbp-68h]
  __int128 v19; // [rsp+C0h] [rbp-60h]
  void *ptr; // [rsp+D8h] [rbp-48h]
  int v21; // [rsp+E4h] [rbp-3Ch]
  void *dest; // [rsp+E8h] [rbp-38h]
  unsigned __int64 i; // [rsp+F0h] [rbp-30h]
  unsigned __int64 v24; // [rsp+F8h] [rbp-28h]
  int v25; // [rsp+104h] [rbp-1Ch]
  char *v26; // [rsp+108h] [rbp-18h]

  v26 = a1;
  dest = 0LL;
  while ( !(unsigned int)is_space(*v26) && *v26 )
    ++v26;
  v21 = (_DWORD)v26 - (_DWORD)a1;
  dest = calloc(1uLL, (signed int)v26 - (signed int)a1 + 1);
  if ( !dest )
  {
    kill(pid, 9);
    exit(-1);
  }
  memcpy(dest, a1, v21);
  g_pszCurrentlyRunningLine__pChar = v26;
  g_lastTokenKind[0] = parse_token_and_return_kind();
  if ( !strncmp((const char *)dest, "b", v21) )
  {
    v19 = 0uLL;
    parse_expr__in_parenthesis((_QWORD *)&v19 + 1);
    parse_expr__in_parenthesis(&v19);
    BREAKPOINT_add_new_with_cb(*((__int64 *)&v19 + 1), v19, 0LL, 0LL);
  }
  else if ( !strncmp((const char *)dest, "bh", v21) )
  {
    v18 = 0LL;
    parse_expr__in_parenthesis(&v18);
    while ( *g_pszCurrentlyRunningLine__pChar == 32 )
      ++g_pszCurrentlyRunningLine__pChar;
    v2 = 0LL;
    v3 = 0LL;
    v4 = 0LL;
    v5 = 0LL;
    v25 = 0;
    while ( !(unsigned int)is_space(*g_pszCurrentlyRunningLine__pChar) && *g_pszCurrentlyRunningLine__pChar )
      *((_BYTE *)&v2 + v25++) = *g_pszCurrentlyRunningLine__pChar++;
    while ( *g_pszCurrentlyRunningLine__pChar == 32 )
      ++g_pszCurrentlyRunningLine__pChar;
    v6 = 0LL;
    v7 = 0LL;
    v8 = 0LL;
    v9 = 0LL;
    v25 = 0;
    while ( !(unsigned int)is_space(*g_pszCurrentlyRunningLine__pChar) && *g_pszCurrentlyRunningLine__pChar )
      *((_BYTE *)&v6 + v25++) = *g_pszCurrentlyRunningLine__pChar++;
    BREAKPOINT_add_new_with_cb(v18, 0LL, (char *)&v2, (__int64)&v6);
  }
  else if ( !strncmp((const char *)dest, "c", v21) )
  {
    BREAKPOINT_run_as_if_triggered_with_CHILD_rip(1);
  }
  else if ( !strncmp((const char *)dest, "w", v21) )
  {
    v17 = 0LL;
    v16 = 0uLL;
    parse_expr__in_parenthesis(&v17);
    parse_expr__in_parenthesis((_QWORD *)&v16 + 1);
    parse_expr__in_parenthesis(&v16);
    if ( !(_QWORD)v16 )
    {
      v24 = *((_QWORD *)&v16 + 1);
      while ( v24 )
      {
        v24 >>= 8;
        *(_QWORD *)&v16 = v16 + 1;
      }
    }
    write_child_mem_by_offset(v17, v16, (__int64)&v16 + 8);
  }
  else if ( !strncmp((const char *)dest, "wr", v21) )
  {
    size = 0uLL;
    parse_expr__in_parenthesis((_QWORD *)&size + 1);
    parse_expr__in_parenthesis(&size);
    ptr = malloc(size);
    for ( i = 0LL; i < (unsigned __int64)size; ++i )
    {
      v1 = (char *)ptr + i;
      *v1 = rand();
    }
    write_child_mem_by_offset(*((__int64 *)&size + 1), size, (__int64)ptr);
    free(ptr);
  }
  else if ( !strncmp((const char *)dest, "f", v21) )
  {
    CHILD__flip_ZF_if_0x7A(v26[1]);
  }
  else if ( !strncmp((const char *)dest, "mc", v21) )
  {
    parse_expr__in_parenthesis(&v14);
    CHILD__emulate_call_with_child_offset(v14);
  }
  else if ( !strncmp((const char *)dest, "a", v21) )
  {
    v13 = 0uLL;
    parse_expr__in_parenthesis((_QWORD *)&v13 + 1);
    parse_expr__in_parenthesis(&v13);
    CHILD__set_reg_value(g_current_reg_name, *((_QWORD *)&v13 + 1) + v13);
    memset(g_current_reg_name, 0, 8uLL);
  }
  else if ( !strncmp((const char *)dest, "x", v21) )
  {
    v12 = 0LL;
    parse_expr__in_parenthesis(&v12);
    CHILD__xor_addr_with_value(v12, 1LL);
  }
  else
  {
    if ( strncmp((const char *)dest, "n", v21) )
    {
      kill(pid, 9);
      exit(-1);
    }
    v11 = 0uLL;
    v10 = 0LL;
    parse_expr__in_parenthesis((_QWORD *)&v11 + 1);
    parse_expr__in_parenthesis(&v11);
    parse_expr__in_parenthesis(&v10);
    CHILD__memcpy(*((__int64 *)&v11 + 1), v10, v11);
  }
}

//----- (0000000000004F1B) ----------------------------------------------------
int __fastcall load_debug_script_file(const char *a1, __int64 a2, int a3)
{
  FILE *v3; // rax
  int v4; // eax
  int v6; // [rsp+Ch] [rbp-74h]
  char templatea[8]; // [rsp+20h] [rbp-60h]
  __int64 v8; // [rsp+30h] [rbp-50h]
  __int64 v9; // [rsp+38h] [rbp-48h]
  char s1[4]; // [rsp+49h] [rbp-37h]
  size_t n; // [rsp+50h] [rbp-30h]
  char *s2; // [rsp+58h] [rbp-28h]
  void *v13; // [rsp+60h] [rbp-20h]
  void *ptr; // [rsp+68h] [rbp-18h]
  char size[12]; // [rsp+74h] [rbp-Ch]

  v6 = a3;
  s2 = 0LL;
  n = 0LL;
  v3 = fopen(a1, "r");
  *(_QWORD *)&size[4] = v3;
  if ( v3 )
  {
    if ( a2 && v6 )
    {
      fseek(*(FILE **)&size[4], 0LL, 2);
      *(_DWORD *)size = ftell(*(FILE **)&size[4]);
      fseek(*(FILE **)&size[4], 0LL, 0);
      ptr = malloc(*(unsigned int *)size);
      fread(ptr, *(unsigned int *)size, 1uLL, *(FILE **)&size[4]);
      v13 = crypto_encrypt_xorStreamCipher(a2, v6, (__int64)ptr, *(int *)size);
      fclose(*(FILE **)&size[4]);
      free(ptr);
      ptr = 0LL;
      strcpy(templatea, "/tmp/XXXXXX");
      v8 = 0LL;
      v9 = 0LL;
      v4 = mkstemp(templatea);
      *(_QWORD *)&size[4] = fdopen(v4, off_8D81);
      fwrite(v13, *(unsigned int *)size, 1uLL, *(FILE **)&size[4]);
      fseek(*(FILE **)&size[4], 0LL, 0);
      free(v13);
      v13 = 0LL;
    }
    strcpy(s1, "begin ");
    while ( getline(&s2, &n, *(FILE **)&size[4]) != -1 )
    {
      if ( !strncmp(s1, s2, 6uLL) )
      {
        if ( !(unsigned __int8)file_process_begin__load_function(s2, *(FILE **)&size[4]) )
        {
          kill(pid, 9);
          exit(-1);
        }
      }
      else
      {
        RUN_line(s2);
        if ( s2 )
        {
          free(s2);
          s2 = 0LL;
          n = 0LL;
        }
      }
    }
    LODWORD(v3) = fclose(*(FILE **)&size[4]);
  }
  return (signed int)v3;
}

//----- (0000000000005170) ----------------------------------------------------
BITMAP *__fastcall BITMAP_from_screenshot(_BYTE *img_data, signed int width, unsigned int height)
{
  signed int count; // [rsp+0h] [rbp-30h]
  BITMAP *v5_bmp; // [rsp+20h] [rbp-10h]
  signed int x; // [rsp+28h] [rbp-8h]
  signed int y; // [rsp+2Ch] [rbp-4h]

  count = height;
  v5_bmp = BITMAP_new_with_h_w(height, width);
  for ( y = 0; y < count; ++y )
  {
    for ( x = 0; x < width; ++x )
      BITMAP_set_pixel_from_RGB_maybe_transparent(
        v5_bmp,
        y,
        x,
        img_data[4 * x + 2 + (signed __int64)(4 * width * y)],
        img_data[4 * x + 1 + (signed __int64)(4 * width * y)],
        img_data[4 * x + (signed __int64)(4 * width * y)]);
  }
  return v5_bmp;
}

//----- (000000000000524E) ----------------------------------------------------
BITMAP *open_display_and_get_image()
{
  signed __int64 v0; // ST20_8
  unsigned int v1; // ST1C_4
  unsigned int v2; // ST18_4
  XImage *v3_img; // ST10_8
  Display *v5; // [rsp+20h] [rbp-10h]
  BITMAP *v6; // [rsp+28h] [rbp-8h]

  v6 = 0LL;
  v5 = XOpenDisplay(0LL);
  if ( v5 )
  {
    v0 = (signed __int64)&v5->screens[(signed __int64)v5->default_screen];
    v1 = *(_DWORD *)(v0 + 24);
    v2 = *(_DWORD *)(v0 + 28);
    v3_img = XGetImage(v5, *(_QWORD *)(v0 + 16), 0, 0, v1, v2, 0xFFFFFFFFFFFFFFFFLL, 2);
    v6 = BITMAP_from_screenshot(v3_img->data, v1, v2);
    ((void (__fastcall *)(XImage *, _QWORD))v3_img->f.destroy_image)(v3_img, v1);
    XCloseDisplay(v5);
  }
  return v6;
}

//----- (000000000000536A) ----------------------------------------------------
signed __int64 __fastcall sub_536A(__int64 a1, _QWORD ***a2, _DWORD *a3)
{
  unsigned int v3; // ST24_4
  unsigned int v4; // ST20_4
  unsigned int v5; // ST1C_4
  signed __int64 result; // rax
  unsigned __int8 v7; // [rsp+1Ah] [rbp-Eh]
  unsigned __int8 v8; // [rsp+1Bh] [rbp-Dh]

  v3 = *(_DWORD *)(**(_QWORD **)a1 + 20LL);
  v4 = *a3 / v3;
  v5 = *a3 % v3;
  v8 = *(_BYTE *)(*(_QWORD *)(8LL * v4 + ***(_QWORD ***)a1) + v5);
  v7 = *(_BYTE *)(*(_QWORD *)(8LL * v4 + ***a2) + v5);
  if ( v8 < v7 )
    result = 0xFFFFFFFFLL;
  else
    result = v8 != v7;
  return result;
}

//----- (000000000000543A) ----------------------------------------------------
void __fastcall sub_543A(void *a1, unsigned __int8 a2)
{
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  if ( *(_BYTE *)a1 == 1 )
  {
    sub_543A(*((_QWORD *)a1 + 4), a2);
    sub_543A(*((_QWORD *)a1 + 5), a2);
    sub_42A4(*((BITMAP ***)a1 + 3));
  }
  else
  {
    for ( i = 0; *((_DWORD *)a1 + 6) > i; ++i )
      sub_42A4(*(BITMAP ***)(8LL * i + *((_QWORD *)a1 + 2)));
    if ( a2 )
    {
      free(*((void **)a1 + 2));
      *((_QWORD *)a1 + 2) = 0LL;
    }
  }
  free(a1);
}

//----- (0000000000005503) ----------------------------------------------------
ENC_PART *__fastcall ENCDATA_load_part_I(FILE *file)
{
  ENC_TYPE_I *v2; // [rsp+10h] [rbp-10h]
  signed int j; // [rsp+18h] [rbp-8h]
  signed int i; // [rsp+1Ch] [rbp-4h]

  v2 = (ENC_TYPE_I *)malloc(0x30uLL);
  v2->type__1_for_I__2_for_L = 1;
  v2->header_firstbyte_y = 0;
  v2->header_secondbyte_x = 0;
  fread(&v2->header_firstbyte_y, 1uLL, 1uLL, file);
  for ( i = 0; !i; i = 1 )
    LOBYTE(v2->header_firstbyte_y) ^= crypto_getByteStream((__int64)g_p_crypto_state_of_child);
  fread(&v2->header_secondbyte_x, 1uLL, 1uLL, file);
  for ( j = 0; !j; j = 1 )
    LOBYTE(v2->header_secondbyte_x) ^= crypto_getByteStream((__int64)g_p_crypto_state_of_child);
  v2->subpart_rect_and_attr = ENCDATA_load_part_I_subpart_rectangle_bytes_with_attr(file);
  v2->child_left = 0LL;
  v2->child_right = 0LL;
  return (ENC_PART *)v2;
}

//----- (0000000000005662) ----------------------------------------------------
ENC_TYPE_L *__fastcall ENCDATA_load_part_L(FILE *a1)
{
  struct ENC_TYPE_I_SUB **v1; // rbx
  ENC_TYPE_L *v3; // [rsp+10h] [rbp-20h]
  u32 j; // [rsp+18h] [rbp-18h]
  unsigned int i; // [rsp+1Ch] [rbp-14h]

  v3 = (ENC_TYPE_L *)malloc(0x30uLL);
  v3->type__1_for_I__2_for_L = 2;
  fread(&v3->dwCount, 4uLL, 1uLL, a1);
  for ( i = 0; i <= 3; ++i )
    *((_BYTE *)&v3->dwCount + i) ^= crypto_getByteStream((__int64)g_p_crypto_state_of_child);
  v3->pArrayRectangles = (struct ENC_TYPE_I_SUB **)malloc(8LL * v3->dwCount);
  for ( j = 0; v3->dwCount > j; ++j )
  {
    v1 = &v3->pArrayRectangles[j];
    *v1 = ENCDATA_load_part_I_subpart_rectangle_bytes_with_attr(a1);
  }
  return v3;
}

//----- (0000000000005775) ----------------------------------------------------
ENC_PART *__fastcall ENCDATA_load_recursive_parts(FILE *file)
{
  char v1; // al
  struct ENC_PART *v2; // rax
  struct ENC_PART *v3; // rax
  char ptr; // [rsp+13h] [rbp-Dh]
  unsigned int i; // [rsp+14h] [rbp-Ch]
  ENC_TYPE_I *v7; // [rsp+18h] [rbp-8h]

  fread(&ptr, 1uLL, 1uLL, file);
  for ( i = 0; !i; ++i )
  {
    v1 = crypto_getByteStream((__int64)g_p_crypto_state_of_child);
    *(&ptr + i) ^= v1;
  }
  if ( ptr == 'I' )
  {
    v7 = (ENC_TYPE_I *)ENCDATA_load_part_I(file);
    v2 = ENCDATA_load_recursive_parts(file);
    v7->child_left = v2;
    v3 = ENCDATA_load_recursive_parts(file);
    v7->child_right = v3;
  }
  else
  {
    if ( ptr != 'L' )
      exit(1);
    v7 = (ENC_TYPE_I *)ENCDATA_load_part_L(file);
  }
  v7->field_08 = 0LL;
  return (ENC_PART *)v7;
}

//----- (0000000000005861) ----------------------------------------------------
__int64 __fastcall ENC_PART_recursive_compure_score(ENC_PART *enc_part, BITMAP *bmp, ENC_TYPE_I_SUB **pResult, float *pMinNorm2, __m128i a5)
{
  __int64 result; // rax
  u32 v6_match_y; // ST34_4
  u32 v7_match_x; // ST30_4
  double v8; // xmm1_8
  __m128i v9__current_min; // xmm0
  double v10; // xmm1_8
  __m128i v11_current_min; // xmm0
  float *v_pMinNorm2; // [rsp+0h] [rbp-40h]
  ENC_TYPE_I_SUB **v_ppBitmapResult; // [rsp+8h] [rbp-38h]
  u8 v14_match_bmp_pxl; // [rsp+2Eh] [rbp-12h]
  u8 v15_match_ref_pxl; // [rsp+2Fh] [rbp-11h]
  float v16_new_score_norm2; // [rsp+38h] [rbp-8h]
  float v16_new_score_norm2__; // [rsp+38h] [rbp-8h]
  unsigned int i; // [rsp+3Ch] [rbp-4h]

  v_ppBitmapResult = pResult;
  v_pMinNorm2 = pMinNorm2;
  if ( enc_part->type__1_for_I__2_for_L == 2 )  // Leaf
  {
    for ( i = 0; ; ++i )
    {
      result = enc_part->u.l.dwCount;
      if ( (unsigned int)result <= i )
        break;
      *(float *)a5.m128i_i32 = BITMAP_get_norm2_delta(enc_part->u.l.pArrayRectangles[i]->pBmp, bmp);
      v16_new_score_norm2 = COERCE_FLOAT(_mm_cvtsi128_si32(a5));
      a5 = (__m128i)*(unsigned int *)v_pMinNorm2;
      if ( *(float *)a5.m128i_i32 >= v16_new_score_norm2 )// norm < current => find out the better matching image
      {
        *v_ppBitmapResult = enc_part->u.l.pArrayRectangles[i];
        a5 = (__m128i)LODWORD(v16_new_score_norm2);
        *v_pMinNorm2 = v16_new_score_norm2;
      }
    }
  }
  else
  {                                             // Tree
    if ( *(_OWORD *)&enc_part->u.i.child_left == 0LL )
      exit(1);
    v6_match_y = enc_part->u.i.header_firstbyte;
    v7_match_x = enc_part->u.i.header_secondbyte;
    v15_match_ref_pxl = enc_part->u.i.subpart_rect_and_attr->pBmp->pPixels[v6_match_y][v7_match_x];
    v14_match_bmp_pxl = bmp->pPixels[v6_match_y][v7_match_x];
    *(float *)a5.m128i_i32 = BITMAP_get_norm2_delta(enc_part->u.i.subpart_rect_and_attr->pBmp, bmp);
    v16_new_score_norm2__ = COERCE_FLOAT(_mm_cvtsi128_si32(a5));
    if ( *v_pMinNorm2 > v16_new_score_norm2__ )
    {
      *v_pMinNorm2 = v16_new_score_norm2__;
      *v_ppBitmapResult = enc_part->u.i.subpart_rect_and_attr;
    }
    v8 = pow((double)(v14_match_bmp_pxl - v15_match_ref_pxl), 2.0);
    v9__current_min = (__m128i)*(unsigned int *)v_pMinNorm2;
    *(double *)v9__current_min.m128i_i64 = *(float *)v9__current_min.m128i_i32;
    if ( *(double *)v9__current_min.m128i_i64 >= v8 )
      ENC_PART_recursive_compure_score(enc_part->u.i.child_left, bmp, v_ppBitmapResult, v_pMinNorm2, v9__current_min);
    v10 = pow((double)(v14_match_bmp_pxl - v15_match_ref_pxl), 2.0);
    result = (__int64)v_pMinNorm2;
    v11_current_min = (__m128i)*(unsigned int *)v_pMinNorm2;
    *(double *)v11_current_min.m128i_i64 = *(float *)v11_current_min.m128i_i32;
    if ( *(double *)v11_current_min.m128i_i64 >= v10 )
      result = ENC_PART_recursive_compure_score(
                 enc_part->u.i.child_right,
                 bmp,
                 v_ppBitmapResult,
                 v_pMinNorm2,
                 v11_current_min);
  }
  return result;
}

//----- (0000000000005A80) ----------------------------------------------------
FILE *__fastcall ENC_fopen_with_read_4_bytes(const char *a1)
{
  unsigned int ptr; // [rsp+14h] [rbp-Ch]
  FILE *stream; // [rsp+18h] [rbp-8h]

  stream = fopen(a1, off_8D88);
  fseek(stream, -4LL, 2);
  if ( fread(&ptr, 4uLL, 1uLL, stream) != 1 )
    exit(1);
  fseek(stream, -4LL - ptr, 2);
  return stream;
}

//----- (0000000000005B3A) ----------------------------------------------------
_BYTE __fastcall BITMAP_set_pixelcol_from_RGB(unsigned __int8 *a1, unsigned __int8 red, int gr, unsigned __int8 blue)
{
  int v4; // eax
  unsigned __int8 v6; // [rsp+4h] [rbp-10h]

  v6 = gr;
  if ( red >= (unsigned __int8)gr )
  {
    if ( (unsigned __int8)gr >= blue )
      gr = blue;
    else
      gr = (unsigned __int8)gr;
  }
  else if ( red >= blue )
  {
    gr = blue;
  }
  else
  {
    gr = red;
  }
  if ( red <= v6 )
  {
    if ( v6 <= blue )
      v4 = blue;
    else
      v4 = v6;
  }
  else if ( red <= blue )
  {
    v4 = blue;
  }
  else
  {
    v4 = red;
  }
  *a1 = (gr + v4) / -2 - 1;
  return *a1;
}

//----- (0000000000005BF2) ----------------------------------------------------
BITMAP *__fastcall BITMAP_insert_transparent_point(BITMAP *bmp, int y, int x)
{
  struct TRANSPARENT_PT_LIST *v3; // ST18_8
  BITMAP *result; // rax
  int v5; // [rsp+0h] [rbp-20h]
  struct TRANSPARENT_PT_LIST *v6; // [rsp+18h] [rbp-8h]

  v5 = x;
  if ( bmp->pTransparentPts_Head )
  {
    v3 = bmp->pTransparentPts_Head->pPrev;
    v3->pNext = (struct TRANSPARENT_PT_LIST *)malloc(0x18uLL);
    v3->pNext->pNext = bmp->pTransparentPts_Head;
    v3->pNext->pPrev = v3;
    bmp->pTransparentPts_Head->pPrev = v3->pNext;
    v6 = v3->pNext;
  }
  else
  {
    bmp->pTransparentPts_Head = (struct TRANSPARENT_PT_LIST *)malloc(0x18uLL);
    v6 = bmp->pTransparentPts_Head;
    v6->pPrev = v6;
    v6->pNext = v6;
  }
  v6->y = y;
  v6->x = v5;
  result = bmp;
  ++bmp->dwCountOfTransparentPts;
  return result;
}

//----- (0000000000005CFF) ----------------------------------------------------
void __fastcall BITMAP_set_pixel_value(BITMAP *bmp, unsigned int y, unsigned int x, u8 val)
{
  bmp->pPixels[y][x] = val;
  if ( !val )
    BITMAP_insert_transparent_point(bmp, y, x);
}

//----- (0000000000005D76) ----------------------------------------------------
void __fastcall BITMAP_set_pixel_from_RGB_maybe_transparent(BITMAP *bmp, unsigned int y, unsigned int x, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6)
{
  unsigned int xa; // [rsp+10h] [rbp-20h]

  xa = x;
  if ( !BITMAP_set_pixelcol_from_RGB(&bmp->pPixels[y][x], a4, a5, a6) )
    BITMAP_insert_transparent_point(bmp, y, xa);
}

//----- (0000000000005E09) ----------------------------------------------------
BITMAP *__fastcall BITMAP_free_one_transparent_pt(BITMAP *a1)
{
  BITMAP *result; // rax
  __int128 v2; // [rsp+10h] [rbp-10h]

  v2 = *(_OWORD *)&a1->pTransparentPts_Head->pNext;
  if ( a1->pTransparentPts_Head == (struct TRANSPARENT_PT_LIST *)v2 )
  {
    free(a1->pTransparentPts_Head);
    a1->pTransparentPts_Head = 0LL;
  }
  else
  {
    free(a1->pTransparentPts_Head);
    a1->pTransparentPts_Head = 0LL;
    a1->pTransparentPts_Head = (struct TRANSPARENT_PT_LIST *)v2;
    *(_QWORD *)(v2 + 16) = *((_QWORD *)&v2 + 1);
    *(_QWORD *)(*((_QWORD *)&v2 + 1) + 8LL) = v2;
  }
  result = a1;
  --a1->dwCountOfTransparentPts;
  return result;
}

//----- (0000000000005ED8) ----------------------------------------------------
void __fastcall BITMAP_free(BITMAP *a1)
{
  u32 i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; a1->dwHeight > i; ++i )
  {
    free(a1->pPixels[i]);
    a1->pPixels[i] = 0LL;
  }
  free(a1->pPixels);
  a1->pPixels = 0LL;
  while ( a1->dwCountOfTransparentPts > 1 )
    BITMAP_free_one_transparent_pt(a1);
  free(a1->pTransparentPts_Head);
  a1->pTransparentPts_Head = 0LL;
  free(a1);
}

//----- (0000000000005FBB) ----------------------------------------------------
void **__fastcall alloc_array_of_memblocks(unsigned int count, unsigned int size)
{
  void **v3; // [rsp+10h] [rbp-20h]
  unsigned int i; // [rsp+1Ch] [rbp-14h]

  v3 = (void **)malloc(8LL * count);
  for ( i = 0; i < count; ++i )
    v3[i] = calloc(1uLL, size);
  return v3;
}

//----- (0000000000006046) ----------------------------------------------------
BITMAP *__fastcall BITMAP_new_with_h_w(unsigned int height, unsigned int width)
{
  UNK_FCT_6046 *v2; // rax
  UNK_FCT_6046 *v3; // ST18_8

  v2 = (UNK_FCT_6046 *)malloc(0x411C0332uLL);
  v3 = v2;
  v2->bmp.dwHeight = height;
  v2->bmp.dwWidth = width;
  *(_OWORD *)&v2->bmp.pPixels = (unsigned __int64)alloc_array_of_memblocks(height, width);
  v3->bmp.dwCountOfTransparentPts = 0;
  return &v3->bmp;
}

//----- (00000000000060CF) ----------------------------------------------------
BITMAP *__fastcall BITMAP_crop_yxhw(BITMAP *a1, unsigned int ypos, unsigned int xpos, unsigned int new_h, unsigned int new_w, _DWORD *pNumberFullPixels)
{
  u8 v6; // ST2F_1
  _DWORD *v8; // [rsp+0h] [rbp-40h]
  unsigned int size; // [rsp+8h] [rbp-38h]
  unsigned int count; // [rsp+Ch] [rbp-34h]
  unsigned int v11; // [rsp+10h] [rbp-30h]
  BITMAP *v_new_bitmap; // [rsp+30h] [rbp-10h]
  unsigned int j; // [rsp+38h] [rbp-8h]
  unsigned int i; // [rsp+3Ch] [rbp-4h]

  v11 = xpos;
  count = new_h;
  size = new_w;
  v8 = pNumberFullPixels;
  v_new_bitmap = BITMAP_new_with_h_w(new_h, new_w);
  *v8 = 0;
  for ( i = ypos; ypos + count > i; ++i )
  {
    for ( j = v11; v11 + size > j; ++j )
    {
      v6 = a1->pPixels[i][j];
      v_new_bitmap->pPixels[i - ypos][j - v11] = v6;
      *v8 += v6 != 0;
    }
  }
  return v_new_bitmap;
}

//----- (00000000000061D5) ----------------------------------------------------
BITMAP *__fastcall BITMAP_shrink_with_scale(BITMAP *a1, unsigned int scale)
{
  u8 v2; // cl
  BITMAP *v4_newbmp; // [rsp+10h] [rbp-20h]
  unsigned int j; // [rsp+1Ch] [rbp-14h]
  unsigned int i; // [rsp+20h] [rbp-10h]
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  unsigned int x; // [rsp+28h] [rbp-8h]
  unsigned int y; // [rsp+2Ch] [rbp-4h]

  v4_newbmp = BITMAP_new_with_h_w(a1->dwHeight / scale, a1->dwWidth / scale);
  for ( y = 0; v4_newbmp->dwHeight > y; ++y )
  {
    for ( x = 0; v4_newbmp->dwWidth > x; ++x )
    {
      v7 = 0;
      for ( i = 0; i < scale; ++i )
      {
        for ( j = 0; j < scale; ++j )
          v7 += a1->pPixels[y * scale + i][x * scale + j] != 0;
      }
      if ( v7 <= 1 )
        v2 = 0;
      else
        v2 = -1;
      BITMAP_set_pixel_value(v4_newbmp, y, x, v2);
    }
  }
  return v4_newbmp;
}

//----- (0000000000006319) ----------------------------------------------------
BITMAP *__fastcall BITMAP_crop_around_filled_pixels_and_give_YX_maxmin(BITMAP *a1, unsigned int *pYmax, unsigned int *pYmin, unsigned int *pXmax, unsigned int *pXmin)
{
  unsigned int *v6; // [rsp+8h] [rbp-48h]
  unsigned int *v7; // [rsp+10h] [rbp-40h]
  unsigned int *v8; // [rsp+18h] [rbp-38h]
  u32 v9; // [rsp+30h] [rbp-20h]
  u32 v10; // [rsp+34h] [rbp-1Ch]
  BITMAP *v11; // [rsp+38h] [rbp-18h]
  unsigned int l; // [rsp+40h] [rbp-10h]
  unsigned int k; // [rsp+44h] [rbp-Ch]
  u32 j; // [rsp+48h] [rbp-8h]
  unsigned int i; // [rsp+4Ch] [rbp-4h]

  v8 = pYmin;
  v7 = pXmax;
  v6 = pXmin;
  v11 = BITMAP_new_with_h_w(a1->dwHeight, a1->dwWidth);
  *pYmax = a1->dwHeight - 1;
  *v8 = 0;
  *v7 = a1->dwWidth - 1;
  *v6 = 0;
  for ( i = 0; a1->dwHeight > i; ++i )
  {
    for ( j = 0; a1->dwWidth > j; ++j )
    {
      if ( a1->pPixels[i][j] )
      {
        if ( *pYmax > i )
          *pYmax = i;
        if ( *v7 > j )
          *v7 = j;
        if ( *v8 < i )
          *v8 = i;
        if ( *v6 < j )
          *v6 = j;
      }
    }
  }
  if ( *v6 && *v8 )
  {
    v10 = (a1->dwHeight + *pYmax - *v8) >> 1;
    v9 = (a1->dwWidth + *v7 - *v6) >> 1;
    for ( k = 0; *v8 - *pYmax >= k; ++k )
    {
      for ( l = 0; *v6 - *v7 >= l; ++l )
        v11->pPixels[v10 + k][v9 + l] = a1->pPixels[*pYmax + k][*v7 + l];
    }
  }
  return v11;
}

//----- (0000000000006559) ----------------------------------------------------
float __fastcall BITMAP_get_norm2_delta(BITMAP *bmp1, BITMAP *bmp2)
{
  float v2; // xmm2_4
  u32 j; // [rsp+14h] [rbp-Ch]
  u32 i; // [rsp+18h] [rbp-8h]
  float v6_delta_squared; // [rsp+1Ch] [rbp-4h]

  v6_delta_squared = 0.0;
  if ( *(_QWORD *)&bmp1->dwHeight != *(_QWORD *)&bmp2->dwHeight )
    exit(1);
  for ( i = 0; bmp1->dwHeight > i; ++i )
  {
    for ( j = 0; bmp1->dwWidth > j; ++j )
    {
      if ( bmp1->pPixels[i][j] != bmp2->pPixels[i][j] )
      {
        v2 = v6_delta_squared + pow((double)(bmp1->pPixels[i][j] - bmp2->pPixels[i][j]), 2.0);
        v6_delta_squared = v2;
      }
    }
  }
  return v6_delta_squared;
}

//----- (00000000000066B7) ----------------------------------------------------
BITMAP *__fastcall ENCDATA_load_rectangle_bytes(FILE *a1)
{
  char v1; // al
  char v2; // al
  char v3; // al
  unsigned int size; // [rsp+18h] [rbp-28h]
  unsigned int count; // [rsp+1Ch] [rbp-24h]
  BITMAP *v7; // [rsp+20h] [rbp-20h]
  unsigned int k; // [rsp+2Ch] [rbp-14h]
  unsigned int offset_in_blk; // [rsp+30h] [rbp-10h]
  unsigned int blk_idx; // [rsp+34h] [rbp-Ch]
  unsigned int j; // [rsp+38h] [rbp-8h]
  unsigned int i; // [rsp+3Ch] [rbp-4h]

  count = 0;
  size = 0;
  fread(&count, 1uLL, 1uLL, a1);
  for ( i = 0; !i; ++i )
  {
    v1 = crypto_getByteStream((__int64)g_p_crypto_state_of_child);
    *((_BYTE *)&count + i) ^= v1;
  }
  fread(&size, 1uLL, 1uLL, a1);
  for ( j = 0; !j; ++j )
  {
    v2 = crypto_getByteStream((__int64)g_p_crypto_state_of_child);
    *((_BYTE *)&size + j) ^= v2;
  }
  v7 = BITMAP_new_with_h_w(count, size);
  for ( blk_idx = 0; v7->dwHeight > blk_idx; ++blk_idx )
  {
    for ( offset_in_blk = 0; v7->dwWidth > offset_in_blk; ++offset_in_blk )
    {
      fread(&v7->pPixels[blk_idx][offset_in_blk], 1uLL, 1uLL, a1);
      for ( k = 0; !k; ++k )
      {
        v3 = crypto_getByteStream((__int64)g_p_crypto_state_of_child);
        v7->pPixels[blk_idx][offset_in_blk + k] ^= v3;
      }
    }
  }
  return v7;
}

//----- (00000000000068AA) ----------------------------------------------------
_BOOL8 __fastcall compute_SHA256_and_compare_with_flag(const char *pszInput)
{
  unsigned __int64 v1; // rax
  char v_digest[47]; // [rsp+10h] [rbp-40h]
  char v4[9]; // [rsp+3Fh] [rbp-11h]
  unsigned int i; // [rsp+4Ch] [rbp-4h]

  *(_QWORD *)&v4[1] = malloc(0x70uLL);
  SHA256_init(*(SHA256_CTX **)&v4[1]);
  v1 = strlen(pszInput);
  SHA256_update(*(SHA256_CTX **)&v4[1], pszInput, v1);
  SHA256_final(*(SHA256_CTX **)&v4[1], v_digest);
  for ( i = 0; i <= 0x1F; ++i )
  {
    if ( i & 1 )
      v_digest[i] ^= 0x19u;
    else
      g_final_flag_encrypted[i] ^= 0x19u;
  }
  free(*(void **)&v4[1]);
  *(_QWORD *)&v4[1] = 0LL;
  return strncmp(v_digest, g_final_flag_encrypted, 0x20uLL) == 0;
}
// 68AA: using guessed type char v_digest[47];

//----- (00000000000069B5) ----------------------------------------------------
void __noreturn sub_69B5()
{
  fwrite("Come on, give me some input to process, man.\n", 1uLL, 0x2DuLL, stdout);
  exit(0);
}

//----- (00000000000069E6) ----------------------------------------------------
void __fastcall __noreturn start_routine(void *a1)
{
  clock_t v1; // ST20_8
  clock_t v2; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    exit(3);
  v2 = clock();
  while ( 1 )
  {
    v1 = clock() - v2;
    if ( (signed int)(((signed __int64)((unsigned __int128)(4835703278458516699LL * (signed __int128)v1) >> 64) >> 18)
                    - (v1 >> 63)) > 14 )
      break;
    sleep(1u);
  }
  sub_69B5();
}

//----- (0000000000006A5D) ----------------------------------------------------
_BOOL8 __fastcall sub_6A5D(void *a1)
{
  pthread_t newthread; // [rsp+18h] [rbp-8h]

  return pthread_create(&newthread, 0LL, (void *(*)(void *))start_routine, a1) != 0;
}

//----- (0000000000006A9A) ----------------------------------------------------
SHA256_CTX *__fastcall SHA256_update_block_512bits(SHA256_CTX *a1, _BYTE *block64)
{
  SHA256_CTX *result; // rax
  int v3[64]; // [rsp+10h] [rbp-130h]
  u32 v4; // [rsp+110h] [rbp-30h]
  u32 v5; // [rsp+114h] [rbp-2Ch]
  int v6; // [rsp+118h] [rbp-28h]
  unsigned int i; // [rsp+11Ch] [rbp-24h]
  u32 v8; // [rsp+120h] [rbp-20h]
  u32 v9; // [rsp+124h] [rbp-1Ch]
  u32 v10; // [rsp+128h] [rbp-18h]
  u32 v11; // [rsp+12Ch] [rbp-14h]
  u32 v12; // [rsp+130h] [rbp-10h]
  u32 v13; // [rsp+134h] [rbp-Ch]
  u32 v14; // [rsp+138h] [rbp-8h]
  u32 v15; // [rsp+13Ch] [rbp-4h]

  i = 0;
  v6 = 0;
  while ( i <= 0xF )
  {
    v3[i++] = ((unsigned __int8)block64[v6 + 2] << 8) | ((unsigned __int8)block64[v6 + 1] << 16) | ((unsigned __int8)block64[v6] << 24) | (unsigned __int8)block64[v6 + 3];
    v6 += 4;
  }
  while ( i <= 0x3F )
  {
    v3[i] = v3[i - 16]
          + (__ROL4__(v3[i - 15], 14) ^ __ROR4__(v3[i - 15], 7) ^ ((unsigned int)v3[i - 15] >> 3))
          + v3[i - 7]
          + (((unsigned int)v3[i - 2] >> 10) ^ __ROL4__(v3[i - 2], 13) ^ __ROL4__(v3[i - 2], 15));
    ++i;
  }
  v15 = a1->H[0];
  v14 = a1->H[1];
  v13 = a1->H[2];
  v12 = a1->H[3];
  v11 = a1->H[4];
  v10 = a1->H[5];
  v9 = a1->H[6];
  v8 = a1->H[7];
  for ( i = 0; i <= 0x3F; ++i )
  {
    v5 = (v10 & v11 ^ v9 & ~v11)
       + (__ROL4__(v11, 7) ^ __ROR4__(v11, 11) ^ __ROR4__(v11, 6))
       + v8
       + dword_8DE0[i]
       + v3[i];
    v4 = (__ROL4__(v15, 10) ^ __ROR4__(v15, 13) ^ __ROR4__(v15, 2)) + (v13 & v15 ^ v14 & v15 ^ v13 & v14);
    v8 = v9;
    v9 = v10;
    v10 = v11;
    v11 = v12 + v5;
    v12 = v13;
    v13 = v14;
    v14 = v15;
    v15 = v5 + v4;
  }
  a1->H[0] += v15;
  a1->H[1] += v14;
  a1->H[2] += v13;
  a1->H[3] += v12;
  a1->H[4] += v11;
  a1->H[5] += v10;
  a1->H[6] += v9;
  result = a1;
  a1->H[7] += v8;
  return result;
}
// 6A9A: using guessed type int var_130[64];

//----- (0000000000006E43) ----------------------------------------------------
SHA256_CTX *__fastcall SHA256_init(SHA256_CTX *ctx)
{
  SHA256_CTX *result; // rax

  ctx->block_pos = 0;
  ctx->unk_field_u64 = 0LL;
  ctx->H[0] = 0x6A09E667;
  ctx->H[1] = 0xBB67AE85;
  ctx->H[2] = 0x3C6EF372;
  ctx->H[3] = 0xA54FF53A;
  ctx->H[4] = 1359893119;
  ctx->H[5] = -1694144372;
  ctx->H[6] = 528734635;
  result = ctx;
  ctx->H[7] = 1541459225;
  return result;
}

//----- (0000000000006EE0) ----------------------------------------------------
__int64 __fastcall SHA256_update(SHA256_CTX *ctx, _BYTE *data, unsigned __int64 size)
{
  __int64 result; // rax
  unsigned __int64 v4; // [rsp+8h] [rbp-28h]
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  v4 = size;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v4 )
      break;
    ctx->current_block[ctx->block_pos++] = data[i];
    if ( ctx->block_pos == 64 )
    {
      SHA256_update_block_512bits(ctx, ctx);
      ctx->unk_field_u64 += 512LL;
      ctx->block_pos = 0;
    }
  }
  return result;
}

//----- (0000000000006F9F) ----------------------------------------------------
SHA256_CTX *__fastcall SHA256_final(SHA256_CTX *a1, _BYTE *pDigest)
{
  unsigned int v2; // eax
  unsigned int v3; // eax
  SHA256_CTX *result; // rax
  u32 v5; // [rsp+1Ch] [rbp-4h]
  unsigned int v6; // [rsp+1Ch] [rbp-4h]
  unsigned int v7; // [rsp+1Ch] [rbp-4h]
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  v5 = a1->block_pos;
  if ( v5 > 0x37 )
  {
    v7 = v5 + 1;
    a1->current_block[a1->block_pos] = -128;
    while ( v7 <= 0x3F )
    {
      v3 = v7++;
      a1->current_block[v3] = 0;
    }
    SHA256_update_block_512bits(a1, a1);
    memset(a1, 0, 0x38uLL);
  }
  else
  {
    v6 = v5 + 1;
    a1->current_block[a1->block_pos] = -128;
    while ( v6 <= 0x37 )
    {
      v2 = v6++;
      a1->current_block[v2] = 0;
    }
  }
  a1->unk_field_u64 += 8 * a1->block_pos;
  a1->current_block[63] = a1->unk_field_u64;
  a1->current_block[62] = LOWORD(a1->unk_field_u64) >> 8;
  a1->current_block[61] = (unsigned int)a1->unk_field_u64 >> 16;
  a1->current_block[60] = (unsigned int)a1->unk_field_u64 >> 24;
  a1->current_block[59] = a1->unk_field_u64 >> 32;
  a1->current_block[58] = (unsigned __int16)(a1->unk_field_u64 >> 32) >> 8;
  a1->current_block[57] = a1->unk_field_u64 >> 48;
  a1->current_block[56] = a1->unk_field_u64 >> 56;
  result = SHA256_update_block_512bits(a1, a1);
  for ( i = 0; i <= 3; ++i )
  {
    pDigest[i] = a1->H[0] >> (-8 * i + 24);
    pDigest[i + 4] = a1->H[1] >> (-8 * i + 24);
    pDigest[i + 8] = a1->H[2] >> (-8 * i + 24);
    pDigest[i + 12] = a1->H[3] >> (-8 * i + 24);
    pDigest[i + 16] = a1->H[4] >> (-8 * i + 24);
    pDigest[i + 20] = a1->H[5] >> (-8 * i + 24);
    pDigest[i + 24] = a1->H[6] >> (-8 * i + 24);
    result = (SHA256_CTX *)(a1->H[7] >> (-8 * i + 24));
    pDigest[i + 28] = (_BYTE)result;
  }
  return result;
}

//----- (00000000000072CD) ----------------------------------------------------
void __fastcall crypto_free_state(void **a1)
{
  free(*a1);
  *a1 = 0LL;
  free(a1);
}

//----- (000000000000730A) ----------------------------------------------------
_DWORD *__fastcall crypto_keySchedule(__int64 a1, int a2)
{
  char v2; // ST1F_1
  _DWORD *v4; // [rsp+20h] [rbp-10h]
  unsigned __int8 v5; // [rsp+2Eh] [rbp-2h]
  unsigned __int8 v6; // [rsp+2Fh] [rbp-1h]

  v4 = malloc(0x10uLL);
  *(_QWORD *)v4 = malloc(0x100uLL);
  v6 = 0;
  v5 = 0;
  do
  {
    *(_BYTE *)(v6 + *(_QWORD *)v4) = v6;
    ++v6;
  }
  while ( v6 );
  do
  {
    v5 ^= *(_BYTE *)(v6 % a2 + a1) ^ *(_BYTE *)(*(_QWORD *)v4 + v6);
    v2 = *(_BYTE *)(*(_QWORD *)v4 + v6);
    *(_BYTE *)(v6 + *(_QWORD *)v4) = *(_BYTE *)(*(_QWORD *)v4 + v5);
    *(_BYTE *)(v5 + *(_QWORD *)v4) = v2;
    ++v6;
  }
  while ( v6 );
  v4[2] = 0;
  v4[3] = 0;
  return v4;
}

//----- (0000000000007429) ----------------------------------------------------
__int64 __fastcall crypto_getByteStream(__int64 a1)
{
  __int64 v1; // ST00_8
  unsigned int v2; // eax
  unsigned int v3; // eax
  char v4; // ST17_1

  v1 = a1;
  v2 = (unsigned int)((*(_DWORD *)(a1 + 8) + 1) >> 31) >> 24;
  *(_DWORD *)(a1 + 8) = (unsigned __int8)(v2 + *(_BYTE *)(a1 + 8) + 1) - v2;
  v3 = (unsigned int)((*(unsigned __int8 *)(*(_QWORD *)v1 + *(signed int *)(v1 + 8)) + *(_DWORD *)(v1 + 12)) >> 31) >> 24;
  *(_DWORD *)(v1 + 12) = (unsigned __int8)(v3 + *(_BYTE *)(*(_QWORD *)v1 + *(signed int *)(v1 + 8))
                                              + *(_BYTE *)(v1 + 12))
                       - v3;
  v4 = *(_BYTE *)(*(_QWORD *)v1 + *(signed int *)(v1 + 8));
  *(_BYTE *)(*(signed int *)(v1 + 8) + *(_QWORD *)v1) = *(_BYTE *)(*(_QWORD *)v1 + *(signed int *)(v1 + 12));
  *(_BYTE *)(*(signed int *)(v1 + 12) + *(_QWORD *)v1) = v4;
  return *(unsigned __int8 *)(*(_QWORD *)a1
                            + (unsigned __int8)(*(_BYTE *)(*(_QWORD *)v1 + *(signed int *)(v1 + 8))
                                              + *(_BYTE *)(*(_QWORD *)v1 + *(signed int *)(v1 + 12))));
}

//----- (000000000000752E) ----------------------------------------------------
_BYTE *__fastcall crypto_encrypt_xorStreamCipher(__int64 a1, int a2, __int64 a3, int a4)
{
  char v4; // r12
  __int64 v6; // [rsp+8h] [rbp-48h]
  int v7; // [rsp+10h] [rbp-40h]
  void **v8; // [rsp+28h] [rbp-28h]
  _BYTE *v9; // [rsp+30h] [rbp-20h]
  int i; // [rsp+3Ch] [rbp-14h]

  v6 = a3;
  v7 = a4;
  v9 = malloc(a4);
  v8 = (void **)crypto_keySchedule(a1, a2);
  for ( i = 0; i < v7; ++i )
  {
    v4 = *(_BYTE *)(i + v6);
    v9[i] = v4 ^ (unsigned __int64)crypto_getByteStream((__int64)v8);
  }
  crypto_free_state(v8);
  return v9;
}

//----- (00000000000075CB) ----------------------------------------------------
_BYTE *__fastcall base64_decode(__int64 a1, unsigned int a2)
{
  int v2; // eax
  _BYTE *v4; // [rsp+10h] [rbp-20h]
  unsigned int j; // [rsp+1Ch] [rbp-14h]
  unsigned int i; // [rsp+20h] [rbp-10h]
  int v7; // [rsp+24h] [rbp-Ch]
  int v8; // [rsp+28h] [rbp-8h]
  int v9; // [rsp+2Ch] [rbp-4h]

  v4 = malloc(a2);
  v9 = 0;
  for ( i = 0; i < a2; i += 4 )
  {
    v8 = 0;
    v7 = 0;
    for ( j = 0; j <= 3; ++j )
    {
      if ( *(_BYTE *)(i + j + a1) != 61 )
      {
        v8 <<= 6;
        v7 += 6;
      }
      if ( *(_BYTE *)(i + j + a1) <= 64 || *(_BYTE *)(i + j + a1) > 90 )
      {
        if ( *(_BYTE *)(i + j + a1) <= 96 || *(_BYTE *)(i + j + a1) > 122 )
        {
          if ( *(_BYTE *)(i + j + a1) <= 47 || *(_BYTE *)(i + j + a1) > 57 )
          {
            if ( *(_BYTE *)(i + j + a1) == 43 )
            {
              v8 |= 0x3Eu;
            }
            else if ( *(_BYTE *)(i + j + a1) == 47 )
            {
              v8 |= 0x3Fu;
            }
            else
            {
              v8 >>= 2;
              v7 -= 2;
            }
          }
          else
          {
            v8 |= *(char *)(i + j + a1) + 4;
          }
        }
        else
        {
          v8 |= *(char *)(i + j + a1) - 71;
        }
      }
      else
      {
        v8 |= *(char *)(i + j + a1) - 65;
      }
    }
    while ( v7 )
    {
      v7 -= 8;
      v2 = v9++;
      v4[v2] = v8 >> v7;
    }
  }
  v4[v9] = 0;
  return v4;
}

//----- (00000000000077E0) ----------------------------------------------------
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r13
  signed __int64 v4; // rbp
  __int64 v5; // rbx

  v3 = a3;
  v4 = &off_20ADA0 - off_20AD98;
  init_proc();
  if ( v4 )
  {
    v5 = 0LL;
    do
      ((void (__fastcall *)(_QWORD, __int64, __int64))off_20AD98[v5++])(a1, a2, v3);
    while ( v4 != v5 );
  }
}
// 20AD98: using guessed type __int64 (__fastcall *off_20AD98[2])();
// 20ADA0: using guessed type __int64 (__fastcall *off_20ADA0)();

//----- (0000000000007854) ----------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 99 function(s)"
